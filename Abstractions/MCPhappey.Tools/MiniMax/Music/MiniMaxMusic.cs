using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.MiniMax.Music;

public static class MiniMaxMusic
{
    private const string LYRICS_GENERATION_URL = "/v1/lyrics_generation";
    private const string MUSIC_GENERATION_URL = "/v1/music_generation";

    private static byte[] HexToBytes(string hex)
    {
        var normalized = hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? hex[2..] : hex;
        return Convert.FromHexString(normalized);
    }

    [Description("Generate lyrics with MiniMax. Supports full song generation and edit/continuation mode.")]
    [McpServerTool(Title = "Generate lyrics with MiniMax", Name = "minimax_music_lyrics_generate", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxMusic_LyricsGenerate(
        [Description("Lyrics generation mode.")] MiniMaxLyricsMode mode,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Theme/style/editing prompt.")] string? prompt = null,
        [Description("Existing lyrics content for edit mode.")] string? lyrics = null,
        [Description("Optional fixed song title.")] string? title = null,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxLyricsGenerateRequest
            {
                Mode = mode,
                Prompt = prompt,
                Lyrics = lyrics,
                Title = title,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            mode = typed.Mode.GetEnumMemberValue(),
            prompt = typed.Prompt,
            lyrics = typed.Lyrics,
            title = typed.Title
        };

        var doc = await minimax.PostAsync(LYRICS_GENERATION_URL, body, cancellationToken);
        var outputName = typed.Filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("txt");
        if (!outputName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
            outputName = $"{outputName}.txt";

        var songTitle = doc.RootElement.TryGetProperty("song_title", out var titleProp) ? titleProp.GetString() : null;
        var styleTags = doc.RootElement.TryGetProperty("style_tags", out var styleProp) ? styleProp.GetString() : null;
        var lyricsOutput = doc.RootElement.TryGetProperty("lyrics", out var lyricsProp) ? lyricsProp.GetString() : null;

        var sb = new StringBuilder();
        if (!string.IsNullOrWhiteSpace(songTitle)) sb.AppendLine($"Title: {songTitle}");
        if (!string.IsNullOrWhiteSpace(styleTags)) sb.AppendLine($"Style: {styleTags}");
        sb.AppendLine();
        if (!string.IsNullOrWhiteSpace(lyricsOutput)) sb.AppendLine(lyricsOutput);

        var uploadedLyrics = await requestContext.Server.Upload(
            serviceProvider,
            outputName,
            BinaryData.FromString(sb.ToString()),
            cancellationToken);

        return uploadedLyrics?.ToResourceLinkCallToolResponse() ?? doc.ToJsonContent(LYRICS_GENERATION_URL).ToCallToolResult();
    });

    [Description("Generate music with MiniMax from lyrics and optional style prompt.")]
    [McpServerTool(Title = "Generate music with MiniMax", Name = "minimax_music_generate", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxMusic_Generate(
        [Description("Lyrics for the song; supports structure tags and new lines."), MaxLength(3500)] string lyrics,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Music generation model.")] MiniMaxMusicModel model = MiniMaxMusicModel.Music25,
        [Description("Optional style/mood prompt.")] string? prompt = null,
        [Description("Enable streaming output.")] bool stream = false,
        [Description("Output format.")] MiniMaxMusicOutputFormat outputFormat = MiniMaxMusicOutputFormat.Hex,
        [Description("Sample rate.")] int? sampleRate = null,
        [Description("Bitrate.")] int? bitrate = null,
        [Description("Audio format.")] MiniMaxMusicAudioFormat? format = null,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxMusicGenerateRequest
            {
                Model = model,
                Prompt = prompt,
                Lyrics = lyrics,
                Stream = stream,
                OutputFormat = outputFormat,
                SampleRate = sampleRate,
                Bitrate = bitrate,
                Format = format,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            model = typed.Model.GetEnumMemberValue(),
            prompt = typed.Prompt,
            lyrics = typed.Lyrics,
            stream = typed.Stream,
            output_format = typed.Stream ? "hex" : typed.OutputFormat.GetEnumMemberValue(),
            audio_setting = new
            {
                sample_rate = typed.SampleRate,
                bitrate = typed.Bitrate,
                format = typed.Format?.GetEnumMemberValue()
            }
        };

        var doc = await minimax.PostAsync(MUSIC_GENERATION_URL, body, cancellationToken);
        if (!typed.Stream
            && doc.RootElement.TryGetProperty("data", out var data)
            && data.ValueKind == JsonValueKind.Object
            && data.TryGetProperty("audio", out var audioProp)
            && audioProp.ValueKind == JsonValueKind.String)
        {
            var audioValue = audioProp.GetString();
            if (!string.IsNullOrWhiteSpace(audioValue))
            {
                var ext = (typed.Format ?? MiniMaxMusicAudioFormat.Mp3).GetEnumMemberValue() ?? "mp3";
                var outputName = typed.Filename?.ToOutputFileName() ?? requestContext.ToOutputFileName(ext);
                if (!outputName.EndsWith($".{ext}", StringComparison.OrdinalIgnoreCase))
                    outputName = $"{outputName}.{ext}";

                ResourceLinkBlock? uploaded;
                if (audioValue.StartsWith("http", StringComparison.OrdinalIgnoreCase))
                {
                    var downloadService = serviceProvider.GetRequiredService<DownloadService>();
                    var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, audioValue, cancellationToken);
                    var file = files.FirstOrDefault() ?? throw new Exception("MiniMax music returned an audio URL but download failed.");

                    uploaded = await requestContext.Server.Upload(
                        serviceProvider,
                        outputName,
                        BinaryData.FromBytes(file.Contents.ToArray()),
                        cancellationToken);
                }
                else
                {
                    uploaded = await requestContext.Server.Upload(
                        serviceProvider,
                        outputName,
                        BinaryData.FromBytes(HexToBytes(audioValue)),
                        cancellationToken);
                }

                return uploaded?.ToResourceLinkCallToolResponse() ?? doc.ToJsonContent(MUSIC_GENERATION_URL).ToCallToolResult();
            }
        }

        return doc.ToJsonContent(MUSIC_GENERATION_URL).ToCallToolResult();
    });
}

[Description("Please confirm the MiniMax lyrics generation request.")]
public class MiniMaxLyricsGenerateRequest
{
    [JsonPropertyName("mode")]
    [Required]
    public MiniMaxLyricsMode Mode { get; set; }

    [JsonPropertyName("prompt")]
    [MaxLength(2000)]
    public string? Prompt { get; set; }

    [JsonPropertyName("lyrics")]
    [MaxLength(3500)]
    public string? Lyrics { get; set; }

    [JsonPropertyName("title")]
    public string? Title { get; set; }

    [JsonPropertyName("filename")]
    public string? Filename { get; set; }
}

[Description("Please confirm the MiniMax music generation request.")]
public class MiniMaxMusicGenerateRequest
{
    [JsonPropertyName("model")]
    [Required]
    public MiniMaxMusicModel Model { get; set; } = MiniMaxMusicModel.Music25;

    [JsonPropertyName("prompt")]
    [MaxLength(2000)]
    public string? Prompt { get; set; }

    [JsonPropertyName("lyrics")]
    [Required]
    [MaxLength(3500)]
    public string Lyrics { get; set; } = default!;

    [JsonPropertyName("stream")]
    public bool Stream { get; set; }

    [JsonPropertyName("output_format")]
    public MiniMaxMusicOutputFormat OutputFormat { get; set; } = MiniMaxMusicOutputFormat.Hex;

    [JsonPropertyName("sample_rate")]
    public int? SampleRate { get; set; }

    [JsonPropertyName("bitrate")]
    public int? Bitrate { get; set; }

    [JsonPropertyName("format")]
    public MiniMaxMusicAudioFormat? Format { get; set; }

    [JsonPropertyName("filename")]
    public string? Filename { get; set; }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxLyricsMode
{
    [EnumMember(Value = "write_full_song")] WriteFullSong,
    [EnumMember(Value = "edit")] Edit
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxMusicModel
{
    [EnumMember(Value = "music-2.5")] Music25
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxMusicOutputFormat
{
    [EnumMember(Value = "url")] Url,
    [EnumMember(Value = "hex")] Hex
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxMusicAudioFormat
{
    [EnumMember(Value = "mp3")] Mp3,
    [EnumMember(Value = "wav")] Wav,
    [EnumMember(Value = "pcm")] Pcm
}

