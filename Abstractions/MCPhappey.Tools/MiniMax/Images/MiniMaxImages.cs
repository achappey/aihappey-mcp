using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.MiniMax.Images;

public static class MiniMaxImages
{
    private const string IMAGE_GENERATION_URL = "/v1/image_generation";

    [Description("Generate image(s) from text using MiniMax image generation.")]
    [McpServerTool(Title = "Generate images with MiniMax", Name = "minimax_images_generate", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxImages_Generate(
        [Description("Text prompt for image generation."), MaxLength(1500)] string prompt,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Image model.")] MiniMaxImageModel model = MiniMaxImageModel.Image01,
        [Description("Aspect ratio.")] MiniMaxImageAspectRatio? aspectRatio = MiniMaxImageAspectRatio.R1x1,
        [Description("Width in px. Used with height; ignored when aspect_ratio is set.")] int? width = null,
        [Description("Height in px. Used with width; ignored when aspect_ratio is set.")] int? height = null,
        [Description("Response format.")] MiniMaxImageResponseFormat responseFormat = MiniMaxImageResponseFormat.Url,
        [Description("Number of images (1-9).")][Range(1, 9)] int n = 1,
        [Description("Random seed.")] long? seed = null,
        [Description("Enable prompt optimizer.")] bool promptOptimizer = false,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxImageGenerateRequest
            {
                Prompt = prompt,
                Model = model,
                AspectRatio = aspectRatio,
                Width = width,
                Height = height,
                ResponseFormat = responseFormat,
                N = n,
                Seed = seed,
                PromptOptimizer = promptOptimizer,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        if ((typed.Width.HasValue && !typed.Height.HasValue) || (!typed.Width.HasValue && typed.Height.HasValue))
            throw new ValidationException("width and height must be set together.");

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            model = typed.Model.GetEnumMemberValue(),
            prompt = typed.Prompt,
            aspect_ratio = typed.AspectRatio?.GetEnumMemberValue(),
            width = typed.Width,
            height = typed.Height,
            response_format = typed.ResponseFormat.GetEnumMemberValue(),
            n = typed.N,
            seed = typed.Seed,
            prompt_optimizer = typed.PromptOptimizer
        };

        var doc = await minimax.PostAsync(IMAGE_GENERATION_URL, body, cancellationToken);
        var uploaded = await TryUploadImageResultsAsync(doc, serviceProvider, requestContext, typed.Filename, cancellationToken);
        if (uploaded != null) return uploaded;

        return doc.ToJsonContent(IMAGE_GENERATION_URL).ToCallToolResult();
    });

    [Description("Generate image(s) from reference image and prompt using MiniMax image-to-image.")]
    [McpServerTool(Title = "Generate images from reference with MiniMax", Name = "minimax_images_generate_from_reference", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxImages_GenerateFromReference(
        [Description("Text prompt for image generation."), MaxLength(1500)] string prompt,
        [Description("Reference image URL or Data URL.")] string imageFile,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Image model.")] MiniMaxImageReferenceModel model = MiniMaxImageReferenceModel.Image01,
        [Description("Aspect ratio.")] MiniMaxImageAspectRatio? aspectRatio = MiniMaxImageAspectRatio.R1x1,
        [Description("Response format.")] MiniMaxImageResponseFormat responseFormat = MiniMaxImageResponseFormat.Url,
        [Description("Number of images (1-9).")][Range(1, 9)] int n = 1,
        [Description("Random seed.")] long? seed = null,
        [Description("Enable prompt optimizer.")] bool promptOptimizer = false,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxImageToImageRequest
            {
                Prompt = prompt,
                Model = model,
                ImageFile = imageFile,
                AspectRatio = aspectRatio,
                ResponseFormat = responseFormat,
                N = n,
                Seed = seed,
                PromptOptimizer = promptOptimizer,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            model = typed.Model.GetEnumMemberValue(),
            prompt = typed.Prompt,
            subject_reference = new[]
            {
                new
                {
                    type = "character",
                    image_file = typed.ImageFile
                }
            },
            aspect_ratio = typed.AspectRatio?.GetEnumMemberValue(),
            response_format = typed.ResponseFormat.GetEnumMemberValue(),
            n = typed.N,
            seed = typed.Seed,
            prompt_optimizer = typed.PromptOptimizer
        };

        var doc = await minimax.PostAsync(IMAGE_GENERATION_URL, body, cancellationToken);
        var uploaded = await TryUploadImageResultsAsync(doc, serviceProvider, requestContext, typed.Filename, cancellationToken);
        if (uploaded != null) return uploaded;

        return doc.ToJsonContent(IMAGE_GENERATION_URL).ToCallToolResult();
    });

    private static async Task<CallToolResult?> TryUploadImageResultsAsync(
        JsonDocument doc,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string? filename,
        CancellationToken cancellationToken)
    {
        if (!doc.RootElement.TryGetProperty("data", out var data) || data.ValueKind != JsonValueKind.Object)
            return null;

        var links = new List<ResourceLinkBlock>();
        var baseName = filename?.ToOutputFileName() ?? requestContext.ToOutputFileName();

        if (data.TryGetProperty("image_urls", out var urls) && urls.ValueKind == JsonValueKind.Array)
        {
            var downloadService = serviceProvider.GetRequiredService<DownloadService>();
            var i = 0;
            foreach (var urlElem in urls.EnumerateArray())
            {
                i++;
                var url = urlElem.GetString();
                if (string.IsNullOrWhiteSpace(url)) continue;

                var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, url, cancellationToken);
                var file = files.FirstOrDefault();
                if (file == null) continue;

                var uploaded = await requestContext.Server.Upload(
                    serviceProvider,
                    $"{baseName}-{i}.png",
                    BinaryData.FromBytes(file.Contents.ToArray()),
                    cancellationToken);

                if (uploaded != null) links.Add(uploaded);
            }
        }

        if (data.TryGetProperty("image_base64", out var base64Array) && base64Array.ValueKind == JsonValueKind.Array)
        {
            var i = links.Count;
            foreach (var b64Elem in base64Array.EnumerateArray())
            {
                i++;
                var b64 = b64Elem.GetString();
                if (string.IsNullOrWhiteSpace(b64)) continue;

                var uploaded = await requestContext.Server.Upload(
                    serviceProvider,
                    $"{baseName}-{i}.png",
                    BinaryData.FromBytes(Convert.FromBase64String(b64)),
                    cancellationToken);

                if (uploaded != null) links.Add(uploaded);
            }
        }

        return links.Count > 0 ? links.ToResourceLinkCallToolResponse() : null;
    }
}

[Description("Please confirm the MiniMax image generation request.")]
public class MiniMaxImageGenerateRequest
{
    [JsonPropertyName("model")]
    [Required]
    public MiniMaxImageModel Model { get; set; } = MiniMaxImageModel.Image01;

    [JsonPropertyName("prompt")]
    [Required]
    [MaxLength(1500)]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("aspect_ratio")]
    public MiniMaxImageAspectRatio? AspectRatio { get; set; } = MiniMaxImageAspectRatio.R1x1;

    [JsonPropertyName("width")]
    public int? Width { get; set; }

    [JsonPropertyName("height")]
    public int? Height { get; set; }

    [JsonPropertyName("response_format")]
    public MiniMaxImageResponseFormat ResponseFormat { get; set; } = MiniMaxImageResponseFormat.Url;

    [JsonPropertyName("n")]
    [Range(1, 9)]
    public int N { get; set; } = 1;

    [JsonPropertyName("seed")]
    public long? Seed { get; set; }

    [JsonPropertyName("prompt_optimizer")]
    public bool PromptOptimizer { get; set; }

    [JsonPropertyName("filename")]
    public string? Filename { get; set; }
}

[Description("Please confirm the MiniMax image-to-image generation request.")]
public class MiniMaxImageToImageRequest
{
    [JsonPropertyName("model")]
    [Required]
    public MiniMaxImageReferenceModel Model { get; set; } = MiniMaxImageReferenceModel.Image01;

    [JsonPropertyName("prompt")]
    [Required]
    [MaxLength(1500)]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("image_file")]
    [Required]
    public string ImageFile { get; set; } = default!;

    [JsonPropertyName("aspect_ratio")]
    public MiniMaxImageAspectRatio? AspectRatio { get; set; } = MiniMaxImageAspectRatio.R1x1;

    [JsonPropertyName("response_format")]
    public MiniMaxImageResponseFormat ResponseFormat { get; set; } = MiniMaxImageResponseFormat.Url;

    [JsonPropertyName("n")]
    [Range(1, 9)]
    public int N { get; set; } = 1;

    [JsonPropertyName("seed")]
    public long? Seed { get; set; }

    [JsonPropertyName("prompt_optimizer")]
    public bool PromptOptimizer { get; set; }

    [JsonPropertyName("filename")]
    public string? Filename { get; set; }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxImageModel
{
    [EnumMember(Value = "image-01")] Image01
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxImageReferenceModel
{
    [EnumMember(Value = "image-01")] Image01,
    [EnumMember(Value = "image-01-live")] Image01Live
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxImageAspectRatio
{
    [EnumMember(Value = "1:1")] R1x1,
    [EnumMember(Value = "16:9")] R16x9,
    [EnumMember(Value = "4:3")] R4x3,
    [EnumMember(Value = "3:2")] R3x2,
    [EnumMember(Value = "2:3")] R2x3,
    [EnumMember(Value = "3:4")] R3x4,
    [EnumMember(Value = "9:16")] R9x16,
    [EnumMember(Value = "21:9")] R21x9
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxImageResponseFormat
{
    [EnumMember(Value = "url")] Url,
    [EnumMember(Value = "base64")] Base64
}

