using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.MiniMax.Speech;

public static class MiniMaxSpeech
{
    private const string T2A_V2 = "/v1/t2a_v2";

    private static byte[] HexToBytes(string hex)
    {
        var normalized = hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? hex[2..] : hex;
        return Convert.FromHexString(normalized);
    }

    private static string InferAudioExtension(JsonDocument doc)
    {
        if (doc.RootElement.TryGetProperty("extra_info", out var extraInfo)
            && extraInfo.ValueKind == JsonValueKind.Object
            && extraInfo.TryGetProperty("audio_format", out var formatProp))
        {
            var ext = formatProp.GetString();
            if (!string.IsNullOrWhiteSpace(ext)) return ext;
        }

        return "mp3";
    }

    private static async Task<CallToolResult?> UploadSpeechResultIfPossible(
        JsonDocument doc,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string? filename,
        CancellationToken cancellationToken)
    {
        if (!doc.RootElement.TryGetProperty("data", out var data) || data.ValueKind != JsonValueKind.Object)
            return null;

        if (!data.TryGetProperty("audio", out var audioProp) || audioProp.ValueKind != JsonValueKind.String)
            return null;

        var audioValue = audioProp.GetString();
        if (string.IsNullOrWhiteSpace(audioValue))
            return null;

        var extension = InferAudioExtension(doc);
        var outputName = filename?.ToOutputFileName() ?? requestContext.ToOutputFileName(extension);
        if (!outputName.EndsWith($".{extension}", StringComparison.OrdinalIgnoreCase))
            outputName = $"{outputName}.{extension}";

        ResourceLinkBlock? uploaded;
        if (audioValue.StartsWith("http", StringComparison.OrdinalIgnoreCase))
        {
            var downloadService = serviceProvider.GetRequiredService<DownloadService>();
            var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, audioValue, cancellationToken);
            var file = files.FirstOrDefault() ?? throw new Exception("MiniMax speech returned an audio URL but download failed.");

            uploaded = await requestContext.Server.Upload(
                serviceProvider,
                outputName,
                BinaryData.FromBytes(file.Contents.ToArray()),
                cancellationToken);
        }
        else
        {
            var bytes = HexToBytes(audioValue);
            uploaded = await requestContext.Server.Upload(
                serviceProvider,
                outputName,
                BinaryData.FromBytes(bytes),
                cancellationToken);
        }

        return uploaded?.ToResourceLinkCallToolResponse();
    }

    [Description("Generate speech from text using MiniMax Text-to-Audio v2.")]
    [McpServerTool(Title = "Generate speech with MiniMax", Name = "minimax_speech_t2a_generate", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxSpeech_T2AGenerate(
        [Description("Text input to synthesize."), MaxLength(10000)] string text,
        [Description("Voice ID to use for synthesis.")] string voiceId,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Speech model.")] MiniMaxSpeechModel model = MiniMaxSpeechModel.Speech28Hd,
        [Description("Enable streaming output.")] bool stream = false,
        [Description("Output format for non-streaming mode.")] MiniMaxSpeechOutputFormat outputFormat = MiniMaxSpeechOutputFormat.Hex,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxSpeechGenerateRequest
            {
                Text = text,
                VoiceId = voiceId,
                Model = model,
                Stream = stream,
                OutputFormat = outputFormat,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            model = typed.Model.GetEnumMemberValue(),
            text = typed.Text,
            stream = typed.Stream,
            output_format = typed.Stream ? "hex" : typed.OutputFormat.GetEnumMemberValue(),
            voice_setting = new
            {
                voice_id = typed.VoiceId,
                speed = typed.Speed,
                vol = typed.Volume,
                pitch = typed.Pitch,
                emotion = typed.Emotion?.GetEnumMemberValue()
            }
        };

        var doc = await minimax.PostAsync(T2A_V2, body, cancellationToken);
        if (!typed.Stream)
        {
            var uploadResult = await UploadSpeechResultIfPossible(doc, serviceProvider, requestContext, typed.Filename, cancellationToken);
            if (uploadResult != null) return uploadResult;
        }

        return doc.ToJsonContent(T2A_V2).ToCallToolResult();
    });

    [Description("Generate speech from text with advanced MiniMax voice effects and subtitle settings.")]
    [McpServerTool(Title = "Generate advanced speech with MiniMax", Name = "minimax_speech_t2a_generate_advanced", Destructive = false)]
    public static async Task<CallToolResult?> MiniMaxSpeech_T2AGenerateAdvanced(
        [Description("Text input to synthesize."), MaxLength(10000)] string text,
        [Description("Voice ID to use for synthesis.")] string voiceId,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Speech model.")] MiniMaxSpeechModel model = MiniMaxSpeechModel.Speech28Hd,
        [Description("Enable streaming output.")] bool stream = false,
        [Description("Enable subtitle generation in non-streaming mode.")] bool subtitleEnable = false,
        [Description("Language boost value, e.g. auto, English, Chinese.")] string? languageBoost = "auto",
        [Description("Output format for non-streaming mode.")] MiniMaxSpeechOutputFormat outputFormat = MiniMaxSpeechOutputFormat.Hex,
        [Description("Voice deep/bright effect [-100, 100].")] int? voiceModifyPitch = null,
        [Description("Voice strong/soft effect [-100, 100].")] int? voiceModifyIntensity = null,
        [Description("Voice timbre effect [-100, 100].")] int? voiceModifyTimbre = null,
        [Description("Optional sound effect.")] MiniMaxSpeechSoundEffect? soundEffect = null,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new MiniMaxSpeechAdvancedRequest
            {
                Text = text,
                VoiceId = voiceId,
                Model = model,
                Stream = stream,
                SubtitleEnable = subtitleEnable,
                LanguageBoost = languageBoost,
                OutputFormat = outputFormat,
                VoiceModifyPitch = voiceModifyPitch,
                VoiceModifyIntensity = voiceModifyIntensity,
                VoiceModifyTimbre = voiceModifyTimbre,
                SoundEffect = soundEffect,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "User input missing.".ToErrorCallToolResponse();

        var minimax = serviceProvider.GetRequiredService<MiniMaxClient>();
        var body = new
        {
            model = typed.Model.GetEnumMemberValue(),
            text = typed.Text,
            stream = typed.Stream,
            subtitle_enable = typed.SubtitleEnable,
            language_boost = typed.LanguageBoost,
            output_format = typed.Stream ? "hex" : typed.OutputFormat.GetEnumMemberValue(),
            voice_setting = new
            {
                voice_id = typed.VoiceId,
                speed = typed.Speed,
                vol = typed.Volume,
                pitch = typed.Pitch,
                emotion = typed.Emotion?.GetEnumMemberValue()
            },
            voice_modify = new
            {
                pitch = typed.VoiceModifyPitch,
                intensity = typed.VoiceModifyIntensity,
                timbre = typed.VoiceModifyTimbre,
                sound_effects = typed.SoundEffect?.GetEnumMemberValue()
            }
        };

        var doc = await minimax.PostAsync(T2A_V2, body, cancellationToken);
        if (!typed.Stream)
        {
            var uploadResult = await UploadSpeechResultIfPossible(doc, serviceProvider, requestContext, typed.Filename, cancellationToken);
            if (uploadResult != null) return uploadResult;
        }

        return doc.ToJsonContent(T2A_V2).ToCallToolResult();
    });
}

[Description("Please confirm the MiniMax speech generation request.")]
public class MiniMaxSpeechGenerateRequest
{
    [JsonPropertyName("model")]
    [Required]
    public MiniMaxSpeechModel Model { get; set; } = MiniMaxSpeechModel.Speech28Hd;

    [JsonPropertyName("text")]
    [Required]
    [MaxLength(10000)]
    public string Text { get; set; } = default!;

    [JsonPropertyName("stream")]
    public bool Stream { get; set; }

    [JsonPropertyName("output_format")]
    public MiniMaxSpeechOutputFormat OutputFormat { get; set; } = MiniMaxSpeechOutputFormat.Hex;

    [JsonPropertyName("voice_id")]
    [Required]
    public string VoiceId { get; set; } = default!;

    [JsonPropertyName("speed")]
    public double Speed { get; set; } = 1.0;

    [JsonPropertyName("volume")]
    public double Volume { get; set; } = 1.0;

    [JsonPropertyName("pitch")]
    public int Pitch { get; set; }

    [JsonPropertyName("emotion")]
    public MiniMaxSpeechEmotion? Emotion { get; set; }

    [JsonPropertyName("filename")]
    public string? Filename { get; set; }
}

[Description("Please confirm the advanced MiniMax speech generation request.")]
public class MiniMaxSpeechAdvancedRequest : MiniMaxSpeechGenerateRequest
{
    [JsonPropertyName("subtitle_enable")]
    public bool SubtitleEnable { get; set; }

    [JsonPropertyName("language_boost")]
    public string? LanguageBoost { get; set; } = "auto";

    [JsonPropertyName("voice_modify_pitch")]
    public int? VoiceModifyPitch { get; set; }

    [JsonPropertyName("voice_modify_intensity")]
    public int? VoiceModifyIntensity { get; set; }

    [JsonPropertyName("voice_modify_timbre")]
    public int? VoiceModifyTimbre { get; set; }

    [JsonPropertyName("sound_effect")]
    public MiniMaxSpeechSoundEffect? SoundEffect { get; set; }
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxSpeechModel
{
    [EnumMember(Value = "speech-2.8-hd")] Speech28Hd,
    [EnumMember(Value = "speech-2.8-turbo")] Speech28Turbo,
    [EnumMember(Value = "speech-2.6-hd")] Speech26Hd,
    [EnumMember(Value = "speech-2.6-turbo")] Speech26Turbo,
    [EnumMember(Value = "speech-02-hd")] Speech02Hd,
    [EnumMember(Value = "speech-02-turbo")] Speech02Turbo,
    [EnumMember(Value = "speech-01-hd")] Speech01Hd,
    [EnumMember(Value = "speech-01-turbo")] Speech01Turbo
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxSpeechOutputFormat
{
    [EnumMember(Value = "url")] Url,
    [EnumMember(Value = "hex")] Hex
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxSpeechEmotion
{
    [EnumMember(Value = "happy")] Happy,
    [EnumMember(Value = "sad")] Sad,
    [EnumMember(Value = "angry")] Angry,
    [EnumMember(Value = "fearful")] Fearful,
    [EnumMember(Value = "disgusted")] Disgusted,
    [EnumMember(Value = "surprised")] Surprised,
    [EnumMember(Value = "calm")] Calm,
    [EnumMember(Value = "fluent")] Fluent,
    [EnumMember(Value = "whisper")] Whisper
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MiniMaxSpeechSoundEffect
{
    [EnumMember(Value = "spacious_echo")] SpaciousEcho,
    [EnumMember(Value = "auditorium_echo")] AuditoriumEcho,
    [EnumMember(Value = "lofi_telephone")] LofiTelephone,
    [EnumMember(Value = "robotic")] Robotic
}

