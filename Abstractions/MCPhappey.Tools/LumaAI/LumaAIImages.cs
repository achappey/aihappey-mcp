using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.LumaAI;

public static class LumaAIImages
{
    private const int DefaultPollIntervalSeconds = 2;
    private const int DefaultMaxWaitSeconds = 300;

    [Description("Generate image(s) with Luma AI, always confirm via elicitation, upload outputs to SharePoint/OneDrive, delete remote generation, and return only resource link blocks.")]
    [McpServerTool(Title = "LumaAI text-to-image", Name = "lumaai_images_generate", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> LumaAI_Images_Generate(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Prompt text describing the image to generate.")] string prompt,
        [Description("Model: photon-1 or photon-flash-1.")] string model = "photon-1",
        [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")] string aspectRatio = "16:9",
        [Description("Output image format: jpg or png.")] string format = "jpg",
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
        {
            var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
                new LumaAIImageGenerateRequest
                {
                    Prompt = prompt,
                    Model = model,
                    AspectRatio = aspectRatio,
                    Format = format,
                    Filename = filename
                },
                cancellationToken);

            if (notAccepted != null) return notAccepted;
            if (typed == null) return "No input data provided".ToErrorCallToolResponse();

            ValidateGenerateRequest(typed);

            var createBody = new JsonObject
            {
                ["generation_type"] = "image",
                ["model"] = typed.Model,
                ["prompt"] = typed.Prompt,
                ["aspect_ratio"] = typed.AspectRatio,
                ["format"] = typed.Format
            };

            return await RunGenerationFlowAsync(
                serviceProvider,
                requestContext,
                createBody,
                DefaultPollIntervalSeconds,
                DefaultMaxWaitSeconds,
                typed.Filename,
                cancellationToken);
        });

    [Description("Modify an image with Luma AI from a single fileUrl, always confirm via elicitation, upload output to SharePoint/OneDrive, delete remote generation, and return only resource link blocks.")]
    [McpServerTool(Title = "LumaAI image modify", Name = "lumaai_images_modify", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> LumaAI_Images_Modify(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Single input image URL (SharePoint/OneDrive/public HTTP).")]
        string fileUrl,
        [Description("Prompt describing the requested image modification.")] string prompt,
        [Description("Model: photon-1 or photon-flash-1.")] string model = "photon-1",
        [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")] string aspectRatio = "16:9",
        [Description("Output image format: jpg or png.")] string format = "jpg",
        [Description("Modify weight in range 0.0-1.0.")][Range(0.0, 1.0)] double weight = 1.0,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
        {
            var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
                new LumaAIImageModifyRequest
                {
                    FileUrl = fileUrl,
                    Prompt = prompt,
                    Model = model,
                    AspectRatio = aspectRatio,
                    Format = format,
                    Weight = weight,
                    Filename = filename
                },
                cancellationToken);

            if (notAccepted != null) return notAccepted;
            if (typed == null) return "No input data provided".ToErrorCallToolResponse();

            ValidateModifyRequest(typed);

            var sourceImageUrl = await GetLumaAccessibleUrlFromFileUrlAsync(
                serviceProvider,
                requestContext,
                typed.FileUrl,
                cancellationToken);

            var createBody = new JsonObject
            {
                ["generation_type"] = "image",
                ["model"] = typed.Model,
                ["prompt"] = typed.Prompt,
                ["aspect_ratio"] = typed.AspectRatio,
                ["format"] = typed.Format,
                ["modify_image_ref"] = new JsonObject
                {
                    ["url"] = sourceImageUrl,
                    ["weight"] = typed.Weight
                }
            };

            return await RunGenerationFlowAsync(
                serviceProvider,
                requestContext,
                createBody,
                DefaultPollIntervalSeconds,
                DefaultMaxWaitSeconds,
                typed.Filename,
                cancellationToken);
        });

    private static async Task<CallToolResult> RunGenerationFlowAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        JsonObject createBody,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        string? filename,
        CancellationToken cancellationToken)
    {
        var client = serviceProvider.GetRequiredService<LumaAIClient>();
        var generationId = string.Empty;

        try
        {
            var created = await client.PostAsync("generations/image", createBody, cancellationToken)
                ?? throw new Exception("LumaAI did not return a response body.");

            generationId = created["id"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(generationId))
                throw new Exception($"LumaAI did not return generation id. Response: {created}");

            var completed = await PollGenerationUntilCompletedAsync(
                client,
                generationId,
                pollIntervalSeconds,
                maxWaitSeconds,
                cancellationToken);

            var imageUrl = completed["assets"]?["image"]?.GetValue<string>();
            if (string.IsNullOrWhiteSpace(imageUrl))
                throw new Exception("LumaAI generation completed but no assets.image URL was returned.");

            var links = await DownloadUploadFromUrlsAsync(
                serviceProvider,
                requestContext,
                [imageUrl],
                filename,
                cancellationToken);

            if (links.Count == 0)
                throw new Exception("LumaAI generation succeeded but no outputs could be uploaded.");

            return links.ToResourceLinkCallToolResponse();
        }
        finally
        {
            if (!string.IsNullOrWhiteSpace(generationId))
                await client.DeleteAsync($"generations/{generationId}", cancellationToken);
        }
    }

    private static async Task<JsonNode> PollGenerationUntilCompletedAsync(
        LumaAIClient client,
        string generationId,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(maxWaitSeconds));

        while (!timeoutCts.IsCancellationRequested)
        {
            var generation = await client.GetAsync($"generations/{generationId}", timeoutCts.Token)
                ?? throw new Exception("LumaAI generation polling returned empty response.");

            var state = generation["state"]?.GetValue<string>()?.Trim().ToLowerInvariant();
            if (state == "completed")
                return generation;

            if (state == "failed")
            {
                var reason = generation["failure_reason"]?.GetValue<string>() ?? "unknown reason";
                throw new Exception($"LumaAI generation {generationId} failed: {reason}");
            }

            await Task.Delay(TimeSpan.FromSeconds(pollIntervalSeconds), timeoutCts.Token);
        }

        throw new TimeoutException($"LumaAI generation {generationId} did not complete within {maxWaitSeconds} seconds.");
    }

    private static async Task<string> GetLumaAccessibleUrlFromFileUrlAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string fileUrl,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, fileUrl, cancellationToken);
        var file = files.FirstOrDefault() ?? throw new InvalidOperationException("Failed to download file content from fileUrl.");

        var sourceFilename = string.IsNullOrWhiteSpace(file.Filename)
            ? $"luma-source{GetImageExtension(null, file.MimeType)}"
            : file.Filename;

        var uploaded = await requestContext.Server.Upload(
            serviceProvider,
            sourceFilename,
            BinaryData.FromBytes(file.Contents.ToArray()),
            cancellationToken);

        if (uploaded == null || string.IsNullOrWhiteSpace(uploaded.Uri))
            throw new Exception("Failed to upload source file for LumaAI processing.");

        return uploaded.Uri;
    }

    private static async Task<List<ResourceLinkBlock>> DownloadUploadFromUrlsAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        IEnumerable<string> urls,
        string? filename,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var links = new List<ResourceLinkBlock>();
        var baseName = filename?.ToOutputFileName() ?? requestContext.ToOutputFileName();
        var i = 0;

        foreach (var url in urls.Where(u => !string.IsNullOrWhiteSpace(u)).Distinct(StringComparer.OrdinalIgnoreCase))
        {
            i++;
            var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, url, cancellationToken);
            var file = files.FirstOrDefault();
            if (file == null)
                continue;

            var ext = GetImageExtension(file.Filename, file.MimeType);
            var uploaded = await requestContext.Server.Upload(
                serviceProvider,
                $"{baseName}-{i}{ext}",
                BinaryData.FromBytes(file.Contents.ToArray()),
                cancellationToken);

            if (uploaded != null)
                links.Add(uploaded);
        }

        return links;
    }

    private static void ValidateGenerateRequest(LumaAIImageGenerateRequest input)
    {
        if (string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required.");

        ValidateCommon(input.Model, input.AspectRatio, input.Format, DefaultPollIntervalSeconds,
            DefaultMaxWaitSeconds);
    }

    private static void ValidateModifyRequest(LumaAIImageModifyRequest input)
    {
        if (string.IsNullOrWhiteSpace(input.FileUrl))
            throw new ValidationException("fileUrl is required.");

        if (string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required.");

        if (input.Weight is < 0.0 or > 1.0)
            throw new ValidationException("weight must be between 0.0 and 1.0.");

        ValidateCommon(input.Model, input.AspectRatio, input.Format, DefaultPollIntervalSeconds,
            DefaultMaxWaitSeconds);
    }

    private static void ValidateCommon(string model, string aspectRatio, string format, int pollIntervalSeconds, int maxWaitSeconds)
    {
        if (!AllowedModels.Contains(model))
            throw new ValidationException("model must be one of: photon-1, photon-flash-1.");

        if (!AllowedAspectRatios.Contains(aspectRatio))
            throw new ValidationException("aspectRatio must be one of: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.");

        if (!AllowedFormats.Contains(format))
            throw new ValidationException("format must be one of: jpg, png.");

        if (pollIntervalSeconds is < 1 or > 60)
            throw new ValidationException("pollIntervalSeconds must be between 1 and 60.");

        if (maxWaitSeconds is < 30 or > 3600)
            throw new ValidationException("maxWaitSeconds must be between 30 and 3600.");
    }

    private static string GetImageExtension(string? filename, string? mimeType)
    {
        var ext = Path.GetExtension(filename ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(ext))
            return ext;

        return mimeType?.ToLowerInvariant() switch
        {
            "image/jpeg" => ".jpg",
            "image/webp" => ".webp",
            "image/gif" => ".gif",
            "image/bmp" => ".bmp",
            _ => ".png"
        };
    }

    private static readonly HashSet<string> AllowedModels = new(StringComparer.OrdinalIgnoreCase)
    {
        "photon-1",
        "photon-flash-1"
    };

    private static readonly HashSet<string> AllowedAspectRatios = new(StringComparer.OrdinalIgnoreCase)
    {
        "1:1",
        "16:9",
        "9:16",
        "4:3",
        "3:4",
        "21:9",
        "9:21"
    };

    private static readonly HashSet<string> AllowedFormats = new(StringComparer.OrdinalIgnoreCase)
    {
        "jpg",
        "png"
    };
}

[Description("Please confirm the LumaAI text-to-image request details.")]
public sealed class LumaAIImageGenerateRequest
{
    [JsonPropertyName("prompt")]
    [Required]
    [Description("Prompt text describing the image to generate.")]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("model")]
    [Required]
    [Description("Model: photon-1 or photon-flash-1.")]
    public string Model { get; set; } = "photon-1";

    [JsonPropertyName("aspectRatio")]
    [Required]
    [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")]
    public string AspectRatio { get; set; } = "16:9";

    [JsonPropertyName("format")]
    [Required]
    [Description("Output image format: jpg or png.")]
    public string Format { get; set; } = "jpg";

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }
}

[Description("Please confirm the LumaAI image modify request details.")]
public sealed class LumaAIImageModifyRequest
{
    [JsonPropertyName("fileUrl")]
    [Required]
    [Description("Single input image URL (SharePoint/OneDrive/public HTTP).")]
    public string FileUrl { get; set; } = default!;

    [JsonPropertyName("prompt")]
    [Required]
    [Description("Prompt describing the requested image modification.")]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("model")]
    [Required]
    [Description("Model: photon-1 or photon-flash-1.")]
    public string Model { get; set; } = "photon-1";

    [JsonPropertyName("aspectRatio")]
    [Required]
    [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")]
    public string AspectRatio { get; set; } = "16:9";

    [JsonPropertyName("format")]
    [Required]
    [Description("Output image format: jpg or png.")]
    public string Format { get; set; } = "jpg";

    [JsonPropertyName("weight")]
    [Range(0.0, 1.0)]
    [Description("Modify weight in range 0.0-1.0.")]
    public double Weight { get; set; } = 1.0;

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }
}

