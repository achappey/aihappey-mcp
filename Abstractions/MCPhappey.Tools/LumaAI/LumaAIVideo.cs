using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.LumaAI;

public static class LumaAIVideo
{
    private const int DefaultPollIntervalSeconds = 2;
    private const int DefaultMaxWaitSeconds = 900;

    [Description("Generate video(s) with Luma AI, always confirm via elicitation, optionally use input fileUrl keyframes, upload resulting video(s) to SharePoint/OneDrive, strictly delete remote generation(s), and return only resource link blocks.")]
    [McpServerTool(Title = "LumaAI video generation", Name = "lumaai_video_generate", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> LumaAI_Video_Generate(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Prompt describing the video to generate.")] string prompt,
        [Description("Model: ray-2 or ray-flash-2.")] string model = "ray-2",
        [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")] string aspectRatio = "16:9",
        [Description("Whether to loop the generated video.")] bool loop = true,
        [Description("Optional input file URL(s) for keyframes. Use one URL for frame0, or two comma-separated URLs for frame0 and frame1.")] string? fileUrl = null,
        [Description("Optional resolution value supported by Luma API.")] string? resolution = null,
        [Description("Optional duration value supported by Luma API.")] string? duration = null,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
        {
            var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
                new LumaAIVideoGenerateRequest
                {
                    Prompt = prompt,
                    Model = model,
                    AspectRatio = aspectRatio,
                    Loop = loop,
                    FileUrl = fileUrl,
                    Resolution = resolution,
                    Duration = duration,
                    Filename = filename
                },
                cancellationToken);

            if (notAccepted != null) return notAccepted;
            if (typed == null) return "No input data provided".ToErrorCallToolResponse();

            ValidateGenerateRequest(typed);

            var client = serviceProvider.GetRequiredService<LumaAIClient>();
            var createdGenerationIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            try
            {
                var createBody = await BuildCreateVideoBodyAsync(serviceProvider, requestContext, typed, cancellationToken);
                var created = await client.PostAsync("generations/video", createBody, cancellationToken)
                    ?? throw new Exception("LumaAI did not return a response body.");

                var generationId = created["id"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(generationId))
                    throw new Exception($"LumaAI did not return generation id. Response: {created}");

                createdGenerationIds.Add(generationId);

                var completed = await PollGenerationUntilCompletedAsync(
                    client,
                    generationId,
                    DefaultPollIntervalSeconds,
                    DefaultMaxWaitSeconds,
                    cancellationToken);

                var links = await DownloadUploadFromGenerationAsync(
                    serviceProvider,
                    requestContext,
                    completed,
                    typed.Filename,
                    cancellationToken);

                if (links.Count == 0)
                    throw new Exception("LumaAI generation succeeded but no outputs could be uploaded.");

                return links.ToResourceLinkCallToolResponse();
            }
            finally
            {
                await DeleteGenerationIdsAsync(client, createdGenerationIds, cancellationToken);
            }
        });

    [Description("Generate video with Luma AI and then add generated audio, always confirm via elicitation, upload resulting video(s) to SharePoint/OneDrive, strictly delete all remote generation(s), and return only resource link blocks.")]
    [McpServerTool(Title = "LumaAI video generation with audio", Name = "lumaai_video_generate_with_audio", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> LumaAI_Video_Generate_WithAudio(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Prompt describing the video to generate.")] string prompt,
        [Description("Audio prompt describing soundtrack style/content.")] string audioPrompt,
        [Description("Model: ray-2 or ray-flash-2.")] string model = "ray-2",
        [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")] string aspectRatio = "16:9",
        [Description("Whether to loop the generated video.")] bool loop = true,
        [Description("Optional input file URL(s) for keyframes. Use one URL for frame0, or two comma-separated URLs for frame0 and frame1.")] string? fileUrl = null,
        [Description("Optional resolution value supported by Luma API.")] string? resolution = null,
        [Description("Optional duration value supported by Luma API.")] string? duration = null,
        [Description("Optional negative prompt for audio generation.")] string? audioNegativePrompt = null,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
        {
            var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
                new LumaAIVideoGenerateWithAudioRequest
                {
                    Prompt = prompt,
                    AudioPrompt = audioPrompt,
                    Model = model,
                    AspectRatio = aspectRatio,
                    Loop = loop,
                    FileUrl = fileUrl,
                    Resolution = resolution,
                    Duration = duration,
                    AudioNegativePrompt = audioNegativePrompt,
                    Filename = filename
                },
                cancellationToken);

            if (notAccepted != null) return notAccepted;
            if (typed == null) return "No input data provided".ToErrorCallToolResponse();

            ValidateGenerateWithAudioRequest(typed);

            var client = serviceProvider.GetRequiredService<LumaAIClient>();
            var createdGenerationIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            try
            {
                var createBody = await BuildCreateVideoBodyAsync(serviceProvider, requestContext, typed, cancellationToken);
                var created = await client.PostAsync("generations/video", createBody, cancellationToken)
                    ?? throw new Exception("LumaAI did not return a response body.");

                var baseGenerationId = created["id"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(baseGenerationId))
                    throw new Exception($"LumaAI did not return generation id. Response: {created}");

                createdGenerationIds.Add(baseGenerationId);

                await PollGenerationUntilCompletedAsync(
                    client,
                    baseGenerationId,
                    DefaultPollIntervalSeconds,
                    DefaultMaxWaitSeconds,
                    cancellationToken);

                var addAudioBody = new JsonObject
                {
                    ["generation_type"] = "add_audio",
                    ["prompt"] = typed.AudioPrompt
                };

                if (!string.IsNullOrWhiteSpace(typed.AudioNegativePrompt))
                    addAudioBody["negative_prompt"] = typed.AudioNegativePrompt;

                var audioResponse = await client.PostAsync($"generations/{baseGenerationId}/audio", addAudioBody, cancellationToken)
                    ?? throw new Exception("LumaAI add-audio endpoint returned empty response.");

                var audioGenerationId = audioResponse["id"]?.GetValue<string>()?.Trim();
                var pollTargetGenerationId = string.IsNullOrWhiteSpace(audioGenerationId)
                    ? baseGenerationId
                    : audioGenerationId;

                if (!string.IsNullOrWhiteSpace(audioGenerationId))
                    createdGenerationIds.Add(audioGenerationId);

                var completed = await PollGenerationUntilCompletedAsync(
                    client,
                    pollTargetGenerationId,
                    DefaultPollIntervalSeconds,
                    DefaultMaxWaitSeconds,
                    cancellationToken);

                var links = await DownloadUploadFromGenerationAsync(
                    serviceProvider,
                    requestContext,
                    completed,
                    typed.Filename,
                    cancellationToken);

                if (links.Count == 0)
                    throw new Exception("LumaAI generation with audio succeeded but no outputs could be uploaded.");

                return links.ToResourceLinkCallToolResponse();
            }
            finally
            {
                await DeleteGenerationIdsAsync(client, createdGenerationIds, cancellationToken);
            }
        });

    private static async Task<JsonObject> BuildCreateVideoBodyAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        LumaAIVideoBaseRequest input,
        CancellationToken cancellationToken)
    {
        var body = new JsonObject
        {
            ["generation_type"] = "video",
            ["prompt"] = input.Prompt,
            ["model"] = input.Model,
            ["aspect_ratio"] = input.AspectRatio,
            ["loop"] = input.Loop
        };

        if (!string.IsNullOrWhiteSpace(input.Resolution))
            body["resolution"] = input.Resolution;

        if (!string.IsNullOrWhiteSpace(input.Duration))
            body["duration"] = input.Duration;

        var keyframeUrls = ParseInputUrls(input.FileUrl);
        if (keyframeUrls.Count > 0)
        {
            var keyframes = new JsonObject();
            var frameIndex = 0;

            foreach (var url in keyframeUrls)
            {
                frameIndex++;
                var lumaAccessibleUrl = await GetLumaAccessibleUrlFromFileUrlAsync(
                    serviceProvider,
                    requestContext,
                    url,
                    cancellationToken);

                keyframes[$"frame{frameIndex - 1}"] = new JsonObject
                {
                    ["type"] = "image",
                    ["url"] = lumaAccessibleUrl
                };
            }

            body["keyframes"] = keyframes;
        }

        return body;
    }

    private static async Task<JsonNode> PollGenerationUntilCompletedAsync(
        LumaAIClient client,
        string generationId,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(maxWaitSeconds));

        while (!timeoutCts.IsCancellationRequested)
        {
            var generation = await client.GetAsync($"generations/{generationId}", timeoutCts.Token)
                ?? throw new Exception("LumaAI generation polling returned empty response.");

            var state = generation["state"]?.GetValue<string>()?.Trim().ToLowerInvariant();
            if (state == "completed")
                return generation;

            if (state == "failed")
            {
                var reason = generation["failure_reason"]?.GetValue<string>() ?? "unknown reason";
                throw new Exception($"LumaAI generation {generationId} failed: {reason}");
            }

            await Task.Delay(TimeSpan.FromSeconds(pollIntervalSeconds), timeoutCts.Token);
        }

        throw new TimeoutException($"LumaAI generation {generationId} did not complete within {maxWaitSeconds} seconds.");
    }

    private static async Task<List<ResourceLinkBlock>> DownloadUploadFromGenerationAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        JsonNode generation,
        string? filename,
        CancellationToken cancellationToken)
    {
        var videoUrls = new List<string>();

        var videoUrl = generation["assets"]?["video"]?.GetValue<string>();
        if (!string.IsNullOrWhiteSpace(videoUrl))
            videoUrls.Add(videoUrl);

        var progressVideoUrl = generation["assets"]?["progress_video"]?.GetValue<string>();
        if (!string.IsNullOrWhiteSpace(progressVideoUrl))
            videoUrls.Add(progressVideoUrl);

        var links = await DownloadUploadFromUrlsAsync(
            serviceProvider,
            requestContext,
            videoUrls,
            filename,
            cancellationToken);

        return links;
    }

    private static async Task<List<ResourceLinkBlock>> DownloadUploadFromUrlsAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        IEnumerable<string> urls,
        string? filename,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var links = new List<ResourceLinkBlock>();
        var baseName = filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("mp4");
        var i = 0;

        foreach (var url in urls.Where(u => !string.IsNullOrWhiteSpace(u)).Distinct(StringComparer.OrdinalIgnoreCase))
        {
            i++;
            var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, url, cancellationToken);
            var file = files.FirstOrDefault();
            if (file == null)
                continue;

            var ext = GetVideoExtension(file.Filename, file.MimeType);
            var uploaded = await requestContext.Server.Upload(
                serviceProvider,
                $"{baseName}-{i}{ext}",
                BinaryData.FromBytes(file.Contents.ToArray()),
                cancellationToken);

            if (uploaded != null)
                links.Add(uploaded);
        }

        return links;
    }

    private static async Task<string> GetLumaAccessibleUrlFromFileUrlAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string fileUrl,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, fileUrl, cancellationToken);
        var file = files.FirstOrDefault() ?? throw new InvalidOperationException("Failed to download file content from fileUrl.");

        var sourceFilename = string.IsNullOrWhiteSpace(file.Filename)
            ? $"luma-video-source{GetImageExtension(null, file.MimeType)}"
            : file.Filename;

        var uploaded = await requestContext.Server.Upload(
            serviceProvider,
            sourceFilename,
            BinaryData.FromBytes(file.Contents.ToArray()),
            cancellationToken);

        if (uploaded == null || string.IsNullOrWhiteSpace(uploaded.Uri))
            throw new Exception("Failed to upload source file for LumaAI processing.");

        return uploaded.Uri;
    }

    private static async Task DeleteGenerationIdsAsync(LumaAIClient client, IEnumerable<string> generationIds, CancellationToken cancellationToken)
    {
        foreach (var generationId in generationIds.Where(x => !string.IsNullOrWhiteSpace(x)).Distinct(StringComparer.OrdinalIgnoreCase))
        {
            try
            {
                await client.DeleteAsync($"generations/{generationId}", cancellationToken);
            }
            catch
            {
                // strict cleanup attempted for every created generation id; errors are swallowed to preserve primary outcome
            }
        }
    }

    private static IReadOnlyList<string> ParseInputUrls(string? fileUrl)
        => string.IsNullOrWhiteSpace(fileUrl)
            ? []
            : fileUrl
                .Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .ToArray();

    private static void ValidateGenerateRequest(LumaAIVideoGenerateRequest input)
    {
        ValidateBase(input);
    }

    private static void ValidateGenerateWithAudioRequest(LumaAIVideoGenerateWithAudioRequest input)
    {
        ValidateBase(input);

        if (string.IsNullOrWhiteSpace(input.AudioPrompt))
            throw new ValidationException("audioPrompt is required.");
    }

    private static void ValidateBase(LumaAIVideoBaseRequest input)
    {
        if (string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required.");

        if (!AllowedModels.Contains(input.Model))
            throw new ValidationException("model must be one of: ray-2, ray-flash-2.");

        if (!AllowedAspectRatios.Contains(input.AspectRatio))
            throw new ValidationException("aspectRatio must be one of: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.");

        var keyframeUrls = ParseInputUrls(input.FileUrl);
        if (keyframeUrls.Count > 2)
            throw new ValidationException("fileUrl accepts up to 2 comma-separated URLs (frame0 and frame1).");
    }

    private static string GetImageExtension(string? filename, string? mimeType)
    {
        var ext = Path.GetExtension(filename ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(ext))
            return ext;

        return mimeType?.ToLowerInvariant() switch
        {
            "image/jpeg" => ".jpg",
            "image/webp" => ".webp",
            "image/gif" => ".gif",
            "image/bmp" => ".bmp",
            _ => ".png"
        };
    }

    private static string GetVideoExtension(string? filename, string? mimeType)
    {
        var ext = Path.GetExtension(filename ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(ext))
            return ext;

        return mimeType?.ToLowerInvariant() switch
        {
            "video/quicktime" => ".mov",
            "video/webm" => ".webm",
            _ => ".mp4"
        };
    }

    private static readonly HashSet<string> AllowedModels = new(StringComparer.OrdinalIgnoreCase)
    {
        "ray-2",
        "ray-flash-2"
    };

    private static readonly HashSet<string> AllowedAspectRatios = new(StringComparer.OrdinalIgnoreCase)
    {
        "1:1",
        "16:9",
        "9:16",
        "4:3",
        "3:4",
        "21:9",
        "9:21"
    };
}

[Description("Please confirm the LumaAI video generation request details.")]
public class LumaAIVideoBaseRequest
{
    [JsonPropertyName("prompt")]
    [Required]
    [Description("Prompt describing the video to generate.")]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("model")]
    [Required]
    [Description("Model: ray-2 or ray-flash-2.")]
    public string Model { get; set; } = "ray-2";

    [JsonPropertyName("aspectRatio")]
    [Required]
    [Description("Aspect ratio: 1:1, 16:9, 9:16, 4:3, 3:4, 21:9, 9:21.")]
    public string AspectRatio { get; set; } = "16:9";

    [JsonPropertyName("loop")]
    [Description("Whether to loop the generated video.")]
    public bool Loop { get; set; } = true;

    [JsonPropertyName("fileUrl")]
    [Description("Optional input file URL(s) for keyframes. Use one URL for frame0, or two comma-separated URLs for frame0 and frame1.")]
    public string? FileUrl { get; set; }

    [JsonPropertyName("resolution")]
    [Description("Optional resolution value supported by Luma API.")]
    public string? Resolution { get; set; }

    [JsonPropertyName("duration")]
    [Description("Optional duration value supported by Luma API.")]
    public string? Duration { get; set; }

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }
}

public sealed class LumaAIVideoGenerateRequest : LumaAIVideoBaseRequest;

[Description("Please confirm the LumaAI video generation with audio request details.")]
public sealed class LumaAIVideoGenerateWithAudioRequest : LumaAIVideoBaseRequest
{
    [JsonPropertyName("audioPrompt")]
    [Required]
    [Description("Audio prompt describing soundtrack style/content.")]
    public string AudioPrompt { get; set; } = default!;

    [JsonPropertyName("audioNegativePrompt")]
    [Description("Optional negative prompt for audio generation.")]
    public string? AudioNegativePrompt { get; set; }
}

