using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.ZAI;

public static class ZAIVideo
{
    private const int DefaultPollIntervalSeconds = 2;
    private const int DefaultMaxWaitSeconds = 600;

    [Description("Generate video with Z.AI (text/image/frames/reference), poll until ready, upload outputs to SharePoint/OneDrive, and return only resource link blocks.")]
    [McpServerTool(Title = "Generate video with Z.AI", Name = "zai_video_generate", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> ZAI_Video_Generate(
        [Description("Video mode: text_to_video, image_to_video, frames_to_video, reference_to_video.")] string mode,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Model code. Allowed by mode: text_to_video -> cogvideox-3 or viduq1-text; image_to_video -> cogvideox-3, viduq1-image, vidu2-image; frames_to_video -> cogvideox-3, viduq1-start-end, vidu2-start-end; reference_to_video -> vidu2-reference.")] string? model = null,
        [Description("Video prompt. Required for text_to_video. Optional for image/frames/reference.")] string? prompt = null,
        [Description("Input file URL(s). For single-input modes provide one URL. For frames/reference provide 2 or 1-3 URLs separated by comma.")] string? fileUrl = null,
        [Description("CogVideoX quality: speed or quality.")] string quality = "speed",
        [Description("Generate audio track when supported.")] bool withAudio = false,
        [Description("Video size. Example: 1920x1080, 1280x720.")] string? size = null,
        [Description("FPS for CogVideoX: 30 or 60.")] int? fps = null,
        [Description("Duration in seconds. Depends on model.")] int? duration = null,
        [Description("Style for viduq1-text: general or anime.")] string? style = null,
        [Description("Aspect ratio for Vidu where supported: 16:9, 9:16, 1:1.")] string? aspectRatio = null,
        [Description("Movement amplitude for Vidu models: auto, small, medium, large.")] string? movementAmplitude = null,
        [Description("Client request id. Optional.")] string? requestId = null,
        [Description("Unique end-user id for abuse monitoring (6-128 chars). Optional.")] string? userId = null,
        [Description("Polling interval in seconds.")][Range(1, 60)] int pollIntervalSeconds = DefaultPollIntervalSeconds,
        [Description("Maximum total wait time in seconds.")][Range(30, 3600)] int maxWaitSeconds = DefaultMaxWaitSeconds,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new ZAIVideoGenerateRequest
            {
                Mode = mode,
                Model = model,
                Prompt = prompt,
                FileUrl = fileUrl,
                Quality = quality,
                WithAudio = withAudio,
                Size = size,
                Fps = fps,
                Duration = duration,
                Style = style,
                AspectRatio = aspectRatio,
                MovementAmplitude = movementAmplitude,
                RequestId = requestId,
                UserId = userId,
                PollIntervalSeconds = pollIntervalSeconds,
                MaxWaitSeconds = maxWaitSeconds,
                Filename = filename
            },
            cancellationToken);

        ValidateInput(typed);

        var resolvedModel = ResolveModel(typed.Mode, typed.Model);
        var urls = ParseInputUrls(typed.FileUrl);

        var body = BuildGenerateBody(typed, resolvedModel, urls);
        var client = serviceProvider.GetRequiredService<ZAIClient>();

        var createResponse = await client.PostAsync("paas/v4/videos/generations", body, null, cancellationToken)
            ?? throw new Exception("Z.AI did not return a response body.");

        var taskId = createResponse["id"]?.GetValue<string>();
        if (string.IsNullOrWhiteSpace(taskId))
            throw new Exception($"Z.AI did not return task id. Response: {createResponse}");

        var completed = await PollAsyncResultAsync(
            client,
            taskId,
            typed.PollIntervalSeconds,
            typed.MaxWaitSeconds,
            cancellationToken);

        var videoResult = completed["video_result"]?.AsArray() ?? [];
        if (videoResult.Count == 0)
            throw new Exception("Video generation succeeded but no video_result entries were returned.");

        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var links = new List<ResourceLinkBlock>();
        var baseName = typed.Filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("mp4");

        var i = 0;
        foreach (var item in videoResult)
        {
            i++;
            var url = item?["url"]?.GetValue<string>();
            if (string.IsNullOrWhiteSpace(url))
                continue;

            var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, url, cancellationToken);
            var file = files.FirstOrDefault();
            if (file == null)
                continue;

            var ext = GetVideoExtension(file.Filename, file.MimeType);
            var uploaded = await requestContext.Server.Upload(
                serviceProvider,
                $"{baseName}-{i}{ext}",
                BinaryData.FromBytes(file.Contents.ToArray()),
                cancellationToken);

            if (uploaded != null)
                links.Add(uploaded);
        }

        if (links.Count == 0)
            throw new Exception("Video generation succeeded but no outputs could be uploaded.");

        return links.ToResourceLinkCallToolResponse();
    });

    private static JsonObject BuildGenerateBody(ZAIVideoGenerateRequest input, string model, IReadOnlyList<string> urls)
    {
        var body = new JsonObject
        {
            ["model"] = model,
            ["prompt"] = input.Prompt,
            ["quality"] = input.Quality,
            ["with_audio"] = input.WithAudio,
            ["size"] = input.Size,
            ["fps"] = input.Fps,
            ["duration"] = input.Duration,
            ["style"] = input.Style,
            ["aspect_ratio"] = input.AspectRatio,
            ["movement_amplitude"] = input.MovementAmplitude,
            ["request_id"] = input.RequestId,
            ["user_id"] = input.UserId
        };

        if (input.Mode.Equals("image_to_video", StringComparison.OrdinalIgnoreCase)
            || input.Mode.Equals("frames_to_video", StringComparison.OrdinalIgnoreCase)
            || input.Mode.Equals("reference_to_video", StringComparison.OrdinalIgnoreCase))
        {
            if (model is "viduq1-image" or "vidu2-image")
            {
                body["image_url"] = urls[0];
            }
            else
            {
                var arr = new JsonArray();
                foreach (var url in urls)
                    arr.Add(url);

                body["image_url"] = arr;
            }
        }

        return body;
    }

    private static async Task<JsonNode> PollAsyncResultAsync(
        ZAIClient client,
        string taskId,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(maxWaitSeconds));

        while (!timeoutCts.IsCancellationRequested)
        {
            var status = await client.GetAsync($"paas/v4/async-result/{taskId}", null, timeoutCts.Token)
                ?? throw new Exception("Z.AI async-result returned empty response.");

            var taskStatus = status["task_status"]?.GetValue<string>()?.Trim().ToUpperInvariant();
            if (taskStatus == "SUCCESS")
                return status;

            if (taskStatus == "FAIL")
                throw new Exception($"Z.AI task {taskId} failed. Response: {status}");

            await Task.Delay(TimeSpan.FromSeconds(pollIntervalSeconds), timeoutCts.Token);
        }

        throw new TimeoutException($"Z.AI task {taskId} did not complete within {maxWaitSeconds} seconds.");
    }

    private static void ValidateInput(ZAIVideoGenerateRequest input)
    {
        var mode = NormalizeMode(input.Mode);
        input.Mode = mode;

        if (!string.IsNullOrWhiteSpace(input.UserId) && (input.UserId.Length < 6 || input.UserId.Length > 128))
            throw new ValidationException("userId must be 6 to 128 characters when provided.");

        if (!string.IsNullOrWhiteSpace(input.Quality)
            && !string.Equals(input.Quality, "speed", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(input.Quality, "quality", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("quality must be one of: speed, quality.");

        if (input.Fps.HasValue && input.Fps is not (30 or 60))
            throw new ValidationException("fps must be 30 or 60 when provided.");

        if (!string.IsNullOrWhiteSpace(input.Style)
            && !string.Equals(input.Style, "general", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(input.Style, "anime", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("style must be one of: general, anime.");

        if (!string.IsNullOrWhiteSpace(input.AspectRatio)
            && input.AspectRatio is not ("16:9" or "9:16" or "1:1"))
            throw new ValidationException("aspectRatio must be one of: 16:9, 9:16, 1:1.");

        if (!string.IsNullOrWhiteSpace(input.MovementAmplitude)
            && !string.Equals(input.MovementAmplitude, "auto", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(input.MovementAmplitude, "small", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(input.MovementAmplitude, "medium", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(input.MovementAmplitude, "large", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("movementAmplitude must be one of: auto, small, medium, large.");

        if (mode == "text_to_video" && string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required for text_to_video.");

        var urls = ParseInputUrls(input.FileUrl);
        if (mode == "image_to_video" && urls.Count != 1)
            throw new ValidationException("image_to_video requires exactly 1 URL in fileUrl.");

        if (mode == "frames_to_video" && urls.Count != 2)
            throw new ValidationException("frames_to_video requires exactly 2 URLs in fileUrl separated by comma.");

        if (mode == "reference_to_video" && (urls.Count < 1 || urls.Count > 3))
            throw new ValidationException("reference_to_video requires 1 to 3 URLs in fileUrl separated by comma.");

        if ((mode == "image_to_video" || mode == "frames_to_video" || mode == "reference_to_video") && urls.Count == 0)
            throw new ValidationException("fileUrl is required for image_to_video, frames_to_video, and reference_to_video.");
    }

    private static string ResolveModel(string mode, string? model)
    {
        var selected = string.IsNullOrWhiteSpace(model)
            ? mode switch
            {
                "text_to_video" => "cogvideox-3",
                "image_to_video" => "viduq1-image",
                "frames_to_video" => "viduq1-start-end",
                "reference_to_video" => "vidu2-reference",
                _ => throw new ValidationException("Unsupported mode.")
            }
            : model.Trim().ToLowerInvariant();

        return mode switch
        {
            "text_to_video" when selected is "cogvideox-3" or "viduq1-text" => selected,
            "image_to_video" when selected is "cogvideox-3" or "viduq1-image" or "vidu2-image" => selected,
            "frames_to_video" when selected is "cogvideox-3" or "viduq1-start-end" or "vidu2-start-end" => selected,
            "reference_to_video" when selected == "vidu2-reference" => selected,
            _ => throw new ValidationException("model is invalid for the selected mode.")
        };
    }

    private static string NormalizeMode(string mode)
    {
        if (string.IsNullOrWhiteSpace(mode))
            throw new ValidationException("mode is required.");

        var normalized = mode.Trim().ToLowerInvariant();
        return normalized switch
        {
            "text_to_video" => normalized,
            "image_to_video" => normalized,
            "frames_to_video" => normalized,
            "reference_to_video" => normalized,
            _ => throw new ValidationException("mode must be one of: text_to_video, image_to_video, frames_to_video, reference_to_video.")
        };
    }

    private static IReadOnlyList<string> ParseInputUrls(string? fileUrl)
        => string.IsNullOrWhiteSpace(fileUrl)
            ? []
            : fileUrl
                .Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .ToArray();

    private static string GetVideoExtension(string? filename, string? mimeType)
    {
        var ext = Path.GetExtension(filename ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(ext))
            return ext;

        return mimeType?.ToLowerInvariant() switch
        {
            "video/quicktime" => ".mov",
            "video/webm" => ".webm",
            _ => ".mp4"
        };
    }
}

[Description("Please confirm the Z.AI video generation request.")]
public sealed class ZAIVideoGenerateRequest
{
    [JsonPropertyName("mode")]
    [Required]
    [Description("Video mode: text_to_video, image_to_video, frames_to_video, reference_to_video.")]
    public string Mode { get; set; } = "text_to_video";

    [JsonPropertyName("model")]
    [Description("Model code for selected mode.")]
    public string? Model { get; set; }

    [JsonPropertyName("prompt")]
    [Description("Video prompt. Required for text_to_video.")]
    public string? Prompt { get; set; }

    [JsonPropertyName("fileUrl")]
    [Description("Input file URL(s). Use a single URL for image mode, or comma-separated URLs for frames/reference modes.")]
    public string? FileUrl { get; set; }

    [JsonPropertyName("quality")]
    [Description("CogVideoX quality: speed or quality.")]
    public string Quality { get; set; } = "speed";

    [JsonPropertyName("withAudio")]
    [Description("Generate audio track when supported.")]
    public bool WithAudio { get; set; }

    [JsonPropertyName("size")]
    [Description("Video size. Example: 1920x1080, 1280x720.")]
    public string? Size { get; set; }

    [JsonPropertyName("fps")]
    [Description("FPS for CogVideoX: 30 or 60.")]
    public int? Fps { get; set; }

    [JsonPropertyName("duration")]
    [Description("Duration in seconds. Depends on model.")]
    public int? Duration { get; set; }

    [JsonPropertyName("style")]
    [Description("Style for viduq1-text: general or anime.")]
    public string? Style { get; set; }

    [JsonPropertyName("aspectRatio")]
    [Description("Aspect ratio where supported: 16:9, 9:16, 1:1.")]
    public string? AspectRatio { get; set; }

    [JsonPropertyName("movementAmplitude")]
    [Description("Movement amplitude where supported: auto, small, medium, large.")]
    public string? MovementAmplitude { get; set; }

    [JsonPropertyName("requestId")]
    [Description("Client request id. Optional.")]
    public string? RequestId { get; set; }

    [JsonPropertyName("userId")]
    [Description("Optional unique end-user id for abuse monitoring (6-128 chars).")]
    public string? UserId { get; set; }

    [JsonPropertyName("pollIntervalSeconds")]
    [Range(1, 60)]
    [Description("Polling interval in seconds.")]
    public int PollIntervalSeconds { get; set; } = 2;

    [JsonPropertyName("maxWaitSeconds")]
    [Range(30, 3600)]
    [Description("Maximum total wait time in seconds.")]
    public int MaxWaitSeconds { get; set; } = 600;

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }

}

