using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Net.Http.Headers;
using System.Text.Json;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.Decart.Video;

public static class DecartVideo
{
    private const string BaseUrl = "https://api.decart.ai";
    private const int DefaultPollIntervalSeconds = 2;
    private const int DefaultMaxWaitSeconds = 600;

    [Description("Generate a video with Decart using text-to-video, image-to-video, or motion mode. Always confirms via elicitation, waits for completion, uploads result, and returns only resource links.")]
    [McpServerTool(Title = "Generate video with Decart", Name = "decart_video_generate", Destructive = false)]
    public static async Task<CallToolResult?> Decart_Video_Generate(
        [Description("Generation mode: text_to_video, image_to_video, or motion.")] string mode,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Prompt for generation. Required for text_to_video and image_to_video.")] string? prompt = null,
        [Description("Input file URL for image_to_video and motion. SharePoint and OneDrive secure links are supported.")] string? fileUrl = null,
        [Description("Trajectory JSON string for motion mode (array of {frame, x, y}).")] string? trajectory = null,
        [Description("Decart model. Allowed: lucy-pro-t2v, lucy-pro-i2v, lucy-motion.")] string? model = null,
        [Description("Output resolution. Allowed: 480p or 720p. Motion mode supports only 720p.")] string resolution = "720p",
        [Description("Output orientation for text_to_video. Example: landscape.")] string orientation = "landscape",
        [Description("Random seed (0 to 4294967295).")][Range(0, 4294967295)] long? seed = null,
        [Description("Whether Decart should enhance the prompt where supported.")] bool enhancePrompt = true,
        [Description("Polling interval in seconds.")][Range(1, 60)] int pollIntervalSeconds = DefaultPollIntervalSeconds,
        [Description("Maximum total wait time in seconds.")][Range(30, 3600)] int maxWaitSeconds = DefaultMaxWaitSeconds,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new DecartGenerateVideoRequest
            {
                Mode = mode,
                Prompt = prompt,
                FileUrl = fileUrl,
                Trajectory = trajectory,
                Model = model,
                Resolution = resolution,
                Orientation = orientation,
                Seed = seed,
                EnhancePrompt = enhancePrompt,
                PollIntervalSeconds = pollIntervalSeconds,
                MaxWaitSeconds = maxWaitSeconds,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "No input data provided".ToErrorCallToolResponse();

        var normalizedMode = NormalizeMode(typed.Mode);
        var resolvedModel = ResolveGenerateModel(normalizedMode, typed.Model);

        ValidateGenerateInput(normalizedMode, typed.Prompt, typed.FileUrl, typed.Trajectory, typed.Resolution, typed.Seed);

        var settings = serviceProvider.GetService<DecartSettings>()
            ?? throw new InvalidOperationException("No DecartSettings found in service provider");

        using var client = CreateClient(settings.ApiKey);
        using var submitRequest = await BuildGenerateRequestAsync(
            serviceProvider,
            requestContext,
            normalizedMode,
            resolvedModel,
            typed,
            cancellationToken);

        var jobId = await SubmitJobAsync(client, submitRequest, cancellationToken);
        await PollUntilCompletedAsync(client, jobId, typed.PollIntervalSeconds, typed.MaxWaitSeconds, cancellationToken);
        var outputBytes = await DownloadJobContentAsync(client, jobId, cancellationToken);

        var finalName = (typed.Filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("mp4")) + ".mp4";
        var uploaded = await requestContext.Server.Upload(
            serviceProvider,
            finalName,
            BinaryData.FromBytes(outputBytes),
            cancellationToken);

        var links = new List<ResourceLinkBlock>();
        if (uploaded != null) links.Add(uploaded);
        return links.ToResourceLinkCallToolResponse();
    });

    [Description("Edit a video with Decart (video-to-video). Always confirms via elicitation, waits for completion, uploads result, and returns only resource links.")]
    [McpServerTool(Title = "Edit video with Decart", Name = "decart_video_edit", Destructive = false)]
    public static async Task<CallToolResult?> Decart_Video_Edit(
        [Description("Prompt describing the video edits to apply.")] string prompt,
        [Description("Input video URL. SharePoint and OneDrive secure links are supported.")] string fileUrl,
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Decart model. Allowed: lucy-pro-v2v.")] string model = "lucy-pro-v2v",
        [Description("Output resolution. Only 720p is supported.")] string resolution = "720p",
        [Description("Random seed (0 to 4294967295).")][Range(0, 4294967295)] long? seed = null,
        [Description("Whether Decart should enhance the prompt.")] bool enhancePrompt = true,
        [Description("Number of inference steps.")] int? numInferenceSteps = null,
        [Description("Polling interval in seconds.")][Range(1, 60)] int pollIntervalSeconds = DefaultPollIntervalSeconds,
        [Description("Maximum total wait time in seconds.")][Range(30, 3600)] int maxWaitSeconds = DefaultMaxWaitSeconds,
        [Description("Output filename without extension. Defaults to autogenerated name.")] string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
    {
        var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
            new DecartEditVideoRequest
            {
                Prompt = prompt,
                FileUrl = fileUrl,
                Model = model,
                Resolution = resolution,
                Seed = seed,
                EnhancePrompt = enhancePrompt,
                NumInferenceSteps = numInferenceSteps,
                PollIntervalSeconds = pollIntervalSeconds,
                MaxWaitSeconds = maxWaitSeconds,
                Filename = filename
            },
            cancellationToken);

        if (notAccepted != null) return notAccepted;
        if (typed == null) return "No input data provided".ToErrorCallToolResponse();

        ValidateEditInput(typed);

        var settings = serviceProvider.GetService<DecartSettings>()
            ?? throw new InvalidOperationException("No DecartSettings found in service provider");

        using var client = CreateClient(settings.ApiKey);
        using var submitRequest = await BuildEditRequestAsync(serviceProvider, requestContext, typed, cancellationToken);

        var jobId = await SubmitJobAsync(client, submitRequest, cancellationToken);
        await PollUntilCompletedAsync(client, jobId, typed.PollIntervalSeconds, typed.MaxWaitSeconds, cancellationToken);
        var outputBytes = await DownloadJobContentAsync(client, jobId, cancellationToken);

        var finalName = (typed.Filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("mp4")) + ".mp4";
        var uploaded = await requestContext.Server.Upload(
            serviceProvider,
            finalName,
            BinaryData.FromBytes(outputBytes),
            cancellationToken);

        var links = new List<ResourceLinkBlock>();
        if (uploaded != null) links.Add(uploaded);
        return links.ToResourceLinkCallToolResponse();
    });

    private static HttpClient CreateClient(string apiKey)
    {
        var client = new HttpClient { BaseAddress = new Uri(BaseUrl) };
        client.DefaultRequestHeaders.Add("X-API-KEY", apiKey);
        return client;
    }

    private static string NormalizeMode(string mode)
    {
        if (string.IsNullOrWhiteSpace(mode))
            throw new ValidationException("mode is required.");

        var normalized = mode.Trim().ToLowerInvariant();
        return normalized switch
        {
            "text_to_video" => normalized,
            "image_to_video" => normalized,
            "motion" => normalized,
            _ => throw new ValidationException("mode must be one of: text_to_video, image_to_video, motion.")
        };
    }

    private static string ResolveGenerateModel(string mode, string? model)
    {
        var selected = string.IsNullOrWhiteSpace(model)
            ? mode switch
            {
                "text_to_video" => "lucy-pro-t2v",
                "image_to_video" => "lucy-pro-i2v",
                "motion" => "lucy-motion",
                _ => throw new ValidationException("Unsupported mode.")
            }
            : model.Trim().ToLowerInvariant();

        return mode switch
        {
            "text_to_video" when selected == "lucy-pro-t2v" => selected,
            "image_to_video" when selected == "lucy-pro-i2v" => selected,
            "motion" when selected == "lucy-motion" => selected,
            _ => throw new ValidationException("model is invalid for the selected mode.")
        };
    }

    private static void ValidateGenerateInput(string mode, string? prompt, string? fileUrl, string? trajectory, string resolution, long? seed)
    {
        ValidateSeed(seed);
        ValidateVideoResolution(resolution, mode == "motion");

        if (mode == "text_to_video" && string.IsNullOrWhiteSpace(prompt))
            throw new ValidationException("prompt is required for text_to_video.");

        if ((mode == "image_to_video" || mode == "motion") && string.IsNullOrWhiteSpace(fileUrl))
            throw new ValidationException("fileUrl is required for image_to_video and motion.");

        if (mode == "image_to_video" && string.IsNullOrWhiteSpace(prompt))
            throw new ValidationException("prompt is required for image_to_video.");

        if (mode == "motion" && string.IsNullOrWhiteSpace(trajectory))
            throw new ValidationException("trajectory is required for motion.");
    }

    private static void ValidateEditInput(DecartEditVideoRequest input)
    {
        if (string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required.");

        if (string.IsNullOrWhiteSpace(input.FileUrl))
            throw new ValidationException("fileUrl is required.");

        if (!string.Equals(input.Model, "lucy-pro-v2v", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("model must be lucy-pro-v2v.");

        ValidateVideoResolution(input.Resolution, force720: true);
        ValidateSeed(input.Seed);
    }

    private static void ValidateVideoResolution(string resolution, bool force720)
    {
        if (string.IsNullOrWhiteSpace(resolution))
            throw new ValidationException("resolution is required.");

        if (force720 && !string.Equals(resolution, "720p", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("resolution must be 720p.");

        if (!force720
            && !string.Equals(resolution, "480p", StringComparison.OrdinalIgnoreCase)
            && !string.Equals(resolution, "720p", StringComparison.OrdinalIgnoreCase))
            throw new ValidationException("resolution must be 480p or 720p.");
    }

    private static void ValidateSeed(long? seed)
    {
        if (!seed.HasValue) return;
        if (seed < 0 || seed > 4294967295)
            throw new ValidationException("seed must be between 0 and 4294967295.");
    }

    private static async Task<HttpRequestMessage> BuildGenerateRequestAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string mode,
        string model,
        DecartGenerateVideoRequest request,
        CancellationToken cancellationToken)
    {
        var path = $"/v1/jobs/{model}";

        if (mode == "text_to_video")
        {
            var body = new List<KeyValuePair<string, string>>
            {
                new("prompt", request.Prompt!),
                new("resolution", request.Resolution),
                new("orientation", request.Orientation),
                new("enhance_prompt", request.EnhancePrompt.ToString().ToLowerInvariant())
            };

            if (request.Seed.HasValue)
                body.Add(new KeyValuePair<string, string>("seed", request.Seed.Value.ToString()));

            return new HttpRequestMessage(HttpMethod.Post, path)
            {
                Content = new FormUrlEncodedContent(body)
            };
        }

        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, request.FileUrl!, cancellationToken);
        var source = files.FirstOrDefault() ?? throw new InvalidOperationException("No file content could be downloaded from fileUrl.");

        var form = new MultipartFormDataContent();
        var dataContent = new ByteArrayContent(source.Contents.ToArray());
        if (!string.IsNullOrWhiteSpace(source.MimeType))
            dataContent.Headers.ContentType = new MediaTypeHeaderValue(source.MimeType);

        form.Add(dataContent, "data", source.Filename ?? "input.bin");
        form.Add(new StringContent(request.Resolution), "resolution");

        if (request.Seed.HasValue)
            form.Add(new StringContent(request.Seed.Value.ToString()), "seed");

        if (mode == "image_to_video")
        {
            form.Add(new StringContent(request.Prompt!), "prompt");
            form.Add(new StringContent(request.EnhancePrompt.ToString().ToLowerInvariant()), "enhance_prompt");
        }
        else
        {
            form.Add(new StringContent(request.Trajectory!), "trajectory");
        }

        return new HttpRequestMessage(HttpMethod.Post, path)
        {
            Content = form
        };
    }

    private static async Task<HttpRequestMessage> BuildEditRequestAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        DecartEditVideoRequest request,
        CancellationToken cancellationToken)
    {
        var path = $"/v1/jobs/{request.Model}";

        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, request.FileUrl, cancellationToken);
        var source = files.FirstOrDefault() ?? throw new InvalidOperationException("No file content could be downloaded from fileUrl.");

        var form = new MultipartFormDataContent();
        form.Add(new StringContent(request.Prompt), "prompt");
        form.Add(new StringContent(request.Resolution), "resolution");
        form.Add(new StringContent(request.EnhancePrompt.ToString().ToLowerInvariant()), "enhance_prompt");

        if (request.Seed.HasValue)
            form.Add(new StringContent(request.Seed.Value.ToString()), "seed");

        if (request.NumInferenceSteps.HasValue)
            form.Add(new StringContent(request.NumInferenceSteps.Value.ToString()), "num_inference_steps");

        var dataContent = new ByteArrayContent(source.Contents.ToArray());
        if (!string.IsNullOrWhiteSpace(source.MimeType))
            dataContent.Headers.ContentType = new MediaTypeHeaderValue(source.MimeType);

        form.Add(dataContent, "data", source.Filename ?? "input.mp4");

        return new HttpRequestMessage(HttpMethod.Post, path)
        {
            Content = form
        };
    }

    private static async Task<string> SubmitJobAsync(HttpClient client, HttpRequestMessage request, CancellationToken cancellationToken)
    {
        using var response = await client.SendAsync(request, cancellationToken);
        var body = await response.Content.ReadAsStringAsync(cancellationToken);
        if (!response.IsSuccessStatusCode)
            throw new Exception($"{response.StatusCode}: {body}");

        using var doc = JsonDocument.Parse(body);
        var jobId = doc.RootElement.TryGetProperty("job_id", out var jobIdProp)
            ? jobIdProp.GetString()
            : null;

        if (string.IsNullOrWhiteSpace(jobId))
            throw new Exception("Decart did not return job_id.");

        return jobId;
    }

    private static async Task PollUntilCompletedAsync(
        HttpClient client,
        string jobId,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(maxWaitSeconds));

        while (!timeoutCts.IsCancellationRequested)
        {
            using var statusResponse = await client.GetAsync($"/v1/jobs/{jobId}", timeoutCts.Token);
            var statusBody = await statusResponse.Content.ReadAsStringAsync(timeoutCts.Token);

            if (!statusResponse.IsSuccessStatusCode)
                throw new Exception($"{statusResponse.StatusCode}: {statusBody}");

            using var statusDoc = JsonDocument.Parse(statusBody);
            var status = statusDoc.RootElement.TryGetProperty("status", out var statusProp)
                ? statusProp.GetString()?.Trim().ToLowerInvariant()
                : null;

            if (status == "completed")
                return;

            if (status == "failed" || status == "cancelled")
                throw new Exception($"Decart job {jobId} ended with status: {status}. Response: {statusBody}");

            await Task.Delay(TimeSpan.FromSeconds(pollIntervalSeconds), timeoutCts.Token);
        }

        throw new TimeoutException($"Decart job {jobId} did not complete within {maxWaitSeconds} seconds.");
    }

    private static async Task<byte[]> DownloadJobContentAsync(HttpClient client, string jobId, CancellationToken cancellationToken)
    {
        using var response = await client.GetAsync($"/v1/jobs/{jobId}/content", cancellationToken);
        var bytes = await response.Content.ReadAsByteArrayAsync(cancellationToken);

        if (!response.IsSuccessStatusCode)
            throw new Exception($"{response.StatusCode}: {System.Text.Encoding.UTF8.GetString(bytes)}");

        return bytes;
    }
}

[Description("Please confirm the Decart video generation request.")]
public sealed class DecartGenerateVideoRequest
{
    [JsonPropertyName("mode")]
    [Required]
    [Description("Generation mode: text_to_video, image_to_video, or motion.")]
    public string Mode { get; set; } = "text_to_video";

    [JsonPropertyName("prompt")]
    [Description("Prompt for generation. Required for text_to_video and image_to_video.")]
    public string? Prompt { get; set; }

    [JsonPropertyName("fileUrl")]
    [Description("Input file URL for image_to_video and motion.")]
    public string? FileUrl { get; set; }

    [JsonPropertyName("trajectory")]
    [Description("Trajectory JSON string for motion mode.")]
    public string? Trajectory { get; set; }

    [JsonPropertyName("model")]
    [Description("Model per mode. Allowed: lucy-pro-t2v, lucy-pro-i2v, lucy-motion.")]
    public string? Model { get; set; }

    [JsonPropertyName("resolution")]
    [Required]
    [Description("Output resolution. Allowed: 480p or 720p. Motion mode supports only 720p.")]
    public string Resolution { get; set; } = "720p";

    [JsonPropertyName("orientation")]
    [Required]
    [Description("Output orientation for text_to_video.")]
    public string Orientation { get; set; } = "landscape";

    [JsonPropertyName("seed")]
    [Description("Random seed for reproducible results (0 to 4294967295).")]
    public long? Seed { get; set; }

    [JsonPropertyName("enhancePrompt")]
    [Description("Whether to let Decart enhance the prompt where supported.")]
    public bool EnhancePrompt { get; set; } = true;

    [JsonPropertyName("pollIntervalSeconds")]
    [Range(1, 60)]
    [Description("Polling interval in seconds.")]
    public int PollIntervalSeconds { get; set; } = 2;

    [JsonPropertyName("maxWaitSeconds")]
    [Range(30, 3600)]
    [Description("Maximum total wait time in seconds.")]
    public int MaxWaitSeconds { get; set; } = 600;

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }
}

[Description("Please confirm the Decart video edit request.")]
public sealed class DecartEditVideoRequest
{
    [JsonPropertyName("prompt")]
    [Required]
    [Description("Text description of the video edits to apply.")]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("fileUrl")]
    [Required]
    [Description("Input video URL. SharePoint and OneDrive secure links are supported.")]
    public string FileUrl { get; set; } = default!;

    [JsonPropertyName("model")]
    [Required]
    [Description("Model. Allowed: lucy-pro-v2v.")]
    public string Model { get; set; } = "lucy-pro-v2v";

    [JsonPropertyName("resolution")]
    [Required]
    [Description("Output resolution. Only 720p is supported.")]
    public string Resolution { get; set; } = "720p";

    [JsonPropertyName("seed")]
    [Description("Random seed for reproducible results (0 to 4294967295).")]
    public long? Seed { get; set; }

    [JsonPropertyName("enhancePrompt")]
    [Description("Whether to let Decart enhance the prompt.")]
    public bool EnhancePrompt { get; set; } = true;

    [JsonPropertyName("numInferenceSteps")]
    [Description("Number of inference steps.")]
    public int? NumInferenceSteps { get; set; }

    [JsonPropertyName("pollIntervalSeconds")]
    [Range(1, 60)]
    [Description("Polling interval in seconds.")]
    public int PollIntervalSeconds { get; set; } = 2;

    [JsonPropertyName("maxWaitSeconds")]
    [Range(30, 3600)]
    [Description("Maximum total wait time in seconds.")]
    public int MaxWaitSeconds { get; set; } = 600;

    [JsonPropertyName("filename")]
    [Description("Output filename without extension.")]
    public string? Filename { get; set; }
}

