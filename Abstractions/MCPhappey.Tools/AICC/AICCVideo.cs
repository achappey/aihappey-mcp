using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using MCPhappey.Common.Extensions;
using MCPhappey.Core.Extensions;
using MCPhappey.Core.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;

namespace MCPhappey.Tools.AICC;

public static class AICCVideo
{
    private const int DefaultPollIntervalSeconds = 3;
    private const int DefaultMaxWaitSeconds = 900;

    [Description("Generate video with AI.CC, always confirm via elicitation, optionally pass exactly one input fileUrl, poll until completion, upload resulting video(s) to SharePoint/OneDrive, and return only resource link blocks.")]
    [McpServerTool(Title = "AICC Video Generate", Name = "aicc_video_generate", Destructive = false, OpenWorld = true)]
    public static async Task<CallToolResult?> AICC_Video_Generate(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        [Description("Video model name (for example: wan2.6-t2v, wan2.6-i2v).")]
        string model = "wan2.6-t2v",
        [Description("Prompt describing the requested video.")]
        string prompt = "",
        [Description("Optional single input media URL (SharePoint/OneDrive/public HTTP).")]
        string? fileUrl = null,
        [Description("Field name under input object that receives fileUrl when provided. Example: audio_url, image_url.")]
        string fileUrlField = "audio_url",
        [Description("Optional output size (provider-specific). Example: 1280*720.")]
        string? size = "1280*720",
        [Description("Optional duration in seconds (provider-specific).")]
        int? duration = 10,
        [Description("Optional shot type (provider-specific). Example: multi.")]
        string? shotType = null,
        [Description("Optional prompt extension flag (provider-specific).")]
        bool? promptExtend = null,
        [Description("Optional random seed.")]
        int? seed = null,
        [Description("Optional output filename without extension. Defaults to autogenerated name.")]
        string? filename = null,
        CancellationToken cancellationToken = default)
        => await requestContext.WithExceptionCheck(async () =>
        {
            var (typed, notAccepted, _) = await requestContext.Server.TryElicit(
                new AICCVideoGenerateRequest
                {
                    Model = model,
                    Prompt = prompt,
                    FileUrl = fileUrl,
                    FileUrlField = fileUrlField,
                    Size = size,
                    Duration = duration,
                    ShotType = shotType,
                    PromptExtend = promptExtend,
                    Seed = seed,
                    Filename = filename,
                },
                cancellationToken);

            if (notAccepted != null) return notAccepted;
            if (typed == null) return "No input data provided".ToErrorCallToolResponse();

            ValidateInput(typed);

            var input = new JsonObject
            {
                ["prompt"] = typed.Prompt
            };

            if (!string.IsNullOrWhiteSpace(typed.FileUrl))
            {
                var remoteUrl = await GetModelAccessibleUrlFromFileUrlAsync(
                    serviceProvider,
                    requestContext,
                    typed.FileUrl,
                    cancellationToken);

                input[typed.FileUrlField] = remoteUrl;
            }

            var parameters = new JsonObject();
            if (!string.IsNullOrWhiteSpace(typed.Size)) parameters["size"] = typed.Size;
            if (typed.Duration.HasValue) parameters["duration"] = typed.Duration.Value;
            if (!string.IsNullOrWhiteSpace(typed.ShotType)) parameters["shot_type"] = typed.ShotType;
            if (typed.PromptExtend.HasValue) parameters["prompt_extend"] = typed.PromptExtend.Value;
            if (typed.Seed.HasValue) parameters["seed"] = typed.Seed.Value;

            var body = new JsonObject
            {
                ["model"] = typed.Model,
                ["input"] = input,
                ["parameters"] = parameters
            };

            var client = serviceProvider.GetRequiredService<AICCClient>();
            var created = await client.PostJsonAsync("/v1/video/generations", body, cancellationToken)
                ?? throw new Exception("AI.CC create video task returned empty response.");

            var taskId = created["id"]?.GetValue<string>()?.Trim()
                         ?? created["task_id"]?.GetValue<string>()?.Trim()
                         ?? string.Empty;

            if (string.IsNullOrWhiteSpace(taskId))
                throw new Exception($"AI.CC did not return task id. Response: {created}");

            var completed = await PollUntilCompletedAsync(
                client,
                taskId,
                DefaultPollIntervalSeconds,
                DefaultMaxWaitSeconds,
                cancellationToken);

            var outputUrls = ExtractOutputVideoUrls(completed);
            if (outputUrls.Count == 0)
                throw new Exception($"AI.CC task {taskId} completed but no output video URL(s) were found. Response: {completed}");

            var links = await DownloadUploadFromUrlsAsync(
                serviceProvider,
                requestContext,
                outputUrls,
                typed.Filename,
                cancellationToken);

            if (links.Count == 0)
                throw new Exception($"AI.CC task {taskId} completed but no output video(s) could be uploaded.");

            return links.ToResourceLinkCallToolResponse();
        });

    private static async Task<JsonNode> PollUntilCompletedAsync(
        AICCClient client,
        string taskId,
        int pollIntervalSeconds,
        int maxWaitSeconds,
        CancellationToken cancellationToken)
    {
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(maxWaitSeconds));

        while (!timeoutCts.IsCancellationRequested)
        {
            var status = await client.GetJsonAsync($"/v1/video/generations/{Uri.EscapeDataString(taskId)}", timeoutCts.Token)
                ?? throw new Exception($"AI.CC status endpoint returned empty response for task {taskId}.");

            var state = status["status"]?.GetValue<string>()?.Trim().ToLowerInvariant() ?? string.Empty;
            if (state is "success" or "succeeded" or "completed" or "done")
                return status;

            if (state is "failed" or "error" or "cancelled" or "canceled")
            {
                var error = status["error"]?.ToJsonString() ?? "unknown error";
                throw new Exception($"AI.CC task {taskId} failed with status '{state}'. Error: {error}");
            }

            await Task.Delay(TimeSpan.FromSeconds(pollIntervalSeconds), timeoutCts.Token);
        }

        throw new TimeoutException($"AI.CC task {taskId} did not complete within {maxWaitSeconds} seconds.");
    }

    private static async Task<string> GetModelAccessibleUrlFromFileUrlAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        string fileUrl,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, fileUrl, cancellationToken);
        var file = files.FirstOrDefault() ?? throw new InvalidOperationException("Failed to download source file from fileUrl.");

        var sourceFilename = string.IsNullOrWhiteSpace(file.Filename)
            ? $"aicc-video-source{GetVideoExtension(null, file.MimeType)}"
            : file.Filename;

        var uploaded = await requestContext.Server.Upload(
            serviceProvider,
            sourceFilename,
            BinaryData.FromBytes(file.Contents.ToArray()),
            cancellationToken);

        if (uploaded == null || string.IsNullOrWhiteSpace(uploaded.Uri))
            throw new Exception("Failed to upload source file for AI.CC processing.");

        return uploaded.Uri;
    }

    private static async Task<List<ResourceLinkBlock>> DownloadUploadFromUrlsAsync(
        IServiceProvider serviceProvider,
        RequestContext<CallToolRequestParams> requestContext,
        IEnumerable<string> urls,
        string? filename,
        CancellationToken cancellationToken)
    {
        var downloadService = serviceProvider.GetRequiredService<DownloadService>();
        var links = new List<ResourceLinkBlock>();
        var baseName = filename?.ToOutputFileName() ?? requestContext.ToOutputFileName("mp4");
        var i = 0;

        foreach (var url in urls.Where(u => !string.IsNullOrWhiteSpace(u)).Distinct(StringComparer.OrdinalIgnoreCase))
        {
            i++;
            var files = await downloadService.DownloadContentAsync(serviceProvider, requestContext.Server, url, cancellationToken);
            var file = files.FirstOrDefault();
            if (file == null)
                continue;

            var ext = GetVideoExtension(file.Filename, file.MimeType);
            var uploaded = await requestContext.Server.Upload(
                serviceProvider,
                $"{baseName}-{i}{ext}",
                BinaryData.FromBytes(file.Contents.ToArray()),
                cancellationToken);

            if (uploaded != null)
                links.Add(uploaded);
        }

        return links;
    }

    private static List<string> ExtractOutputVideoUrls(JsonNode root)
    {
        var urls = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        // Prefer known output sections first.
        CollectUrlsFromNode(root["data"], urls);
        CollectUrlsFromNode(root["output"], urls);
        CollectUrlsFromNode(root["result"], urls);
        CollectUrlsFromNode(root["video"], urls);
        CollectUrlsFromNode(root["videos"], urls);
        CollectUrlsFromNode(root["video_result"], urls);

        // Fallback: scan full payload when known sections didn't produce links.
        if (urls.Count == 0)
            CollectUrlsFromNode(root, urls);

        return [.. urls];
    }

    private static void CollectUrlsFromNode(JsonNode? node, HashSet<string> urls)
    {
        if (node == null)
            return;

        switch (node)
        {
            case JsonObject obj:
                foreach (var kv in obj)
                {
                    var key = kv.Key;
                    var value = kv.Value;
                    if (value == null)
                        continue;

                    if (value is JsonValue jv && jv.TryGetValue<string>(out var s) && !string.IsNullOrWhiteSpace(s))
                    {
                        if (IsOutputUrlKey(key)
                            && Uri.TryCreate(s, UriKind.Absolute, out var uri)
                            && (uri.Scheme == Uri.UriSchemeHttp || uri.Scheme == Uri.UriSchemeHttps))
                        {
                            urls.Add(s);
                        }
                    }

                    CollectUrlsFromNode(value, urls);
                }

                break;

            case JsonArray arr:
                foreach (var child in arr)
                    CollectUrlsFromNode(child, urls);

                break;
        }
    }

    private static bool IsOutputUrlKey(string key)
    {
        var normalized = key.Trim().ToLowerInvariant();

        if (normalized is "audio_url" or "image_url" or "input_url" or "fileurl")
            return false;

        return normalized.Contains("url", StringComparison.Ordinal)
               && (normalized.Contains("video", StringComparison.Ordinal)
                   || normalized is "url" or "download_url" or "output_url" or "file_uri" or "fileuri");
    }

    private static void ValidateInput(AICCVideoGenerateRequest input)
    {
        if (string.IsNullOrWhiteSpace(input.Model))
            throw new ValidationException("model is required.");

        if (string.IsNullOrWhiteSpace(input.Prompt))
            throw new ValidationException("prompt is required.");

        if (!string.IsNullOrWhiteSpace(input.FileUrlField)
            && !input.FileUrlField.Contains('_')
            && !input.FileUrlField.Contains("url", StringComparison.OrdinalIgnoreCase))
        {
            throw new ValidationException("fileUrlField should be a URL-style field name like audio_url or image_url.");
        }
    }

    private static string GetVideoExtension(string? filename, string? mimeType)
    {
        var ext = Path.GetExtension(filename ?? string.Empty);
        if (!string.IsNullOrWhiteSpace(ext))
            return ext;

        return mimeType?.ToLowerInvariant() switch
        {
            "video/quicktime" => ".mov",
            "video/x-msvideo" => ".avi",
            "video/webm" => ".webm",
            _ => ".mp4"
        };
    }
}

[Description("Please confirm the AICC video generation request.")]
public sealed class AICCVideoGenerateRequest
{
    [JsonPropertyName("model")]
    [Required]
    [Description("Video model name.")]
    public string Model { get; set; } = "wan2.6-t2v";

    [JsonPropertyName("prompt")]
    [Required]
    [Description("Prompt text for generation.")]
    public string Prompt { get; set; } = default!;

    [JsonPropertyName("fileUrl")]
    [Description("Optional single input media URL (SharePoint/OneDrive/public HTTP).")]
    public string? FileUrl { get; set; }

    [JsonPropertyName("fileUrlField")]
    [Required]
    [Description("Input object field name that receives fileUrl when provided, for example audio_url or image_url.")]
    public string FileUrlField { get; set; } = "audio_url";

    [JsonPropertyName("size")]
    [Description("Optional output size (provider-specific).")]
    public string? Size { get; set; } = "1280*720";

    [JsonPropertyName("duration")]
    [Description("Optional duration in seconds (provider-specific).")]
    public int? Duration { get; set; } = 10;

    [JsonPropertyName("shotType")]
    [Description("Optional shot type (provider-specific).")]
    public string? ShotType { get; set; }

    [JsonPropertyName("promptExtend")]
    [Description("Optional prompt extension flag (provider-specific).")]
    public bool? PromptExtend { get; set; }

    [JsonPropertyName("seed")]
    [Description("Optional random seed.")]
    public int? Seed { get; set; }

    [JsonPropertyName("filename")]
    [Description("Output filename without extension. Defaults to autogenerated name.")]
    public string? Filename { get; set; }
}
