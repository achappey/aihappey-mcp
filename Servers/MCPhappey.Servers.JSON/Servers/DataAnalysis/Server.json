{
  "serverInfo": {
    "name": "DataAnalysis",
    "title": "Data Analysis",
    "version": "1.0.0",
    "description": "Analyze CSV tables: compute, filter, group, sort and summarize data for insights and reports."
  },
  "instructions": "Treat every row as a case‑insensitive Dictionary<string,object?> called it. Build your pipeline in the fixed order compute → filter → group/aggregate → select → sort → limit. **Compute**: for each entry in the compute map evaluate the supplied Dynamic‑LINQ expression on a one‑row array new[]{it}.AsQueryable().Select(\"new(\" + expr + \" as _v)\").First()._v and store the value under the entry’s key; if evaluation throws set that cell to \"#ERROR: \" + ex.Message so the rest of the query continues. Never call ToString() or any other instance method on an untyped Object inside the expression; instead cast or convert first – for strings use Convert.ToString(x) or rely on CSV values already being strings. Constants must use double quotes, e.g. \"Unknown\", never single quotes. **Helper Accessor**: if a column name matches ^[A-Za-z_]\\w*$ return it verbatim, otherwise return \"((System.Collections.Generic.IDictionary<string,object?>)it)[\\\"\" + col + \"\\\"]\" so Dynamic‑LINQ always sees a real dictionary indexer and never a KeyValuePair. **Helper Alias**: replace every non‑alphanumeric character with _ and prefix _ if the first character is a digit; this gives a legal identifier for group keys. **Filter**: if filter text is not empty run query = query.Where(filter). **Group/Aggregate**: build keyExpr 'new(' + string.Join(',', groupBy.Select(c => Accessor(c) + \" as \" + Alias(c))) + ')'; build keySelect 'Key.' + Alias(c) + ' as ' + c.Split('.').Last(); scan the select list and add Max(Convert.ToDecimal(Accessor(col))) for every selected column that is not in groupBy and not already in aggregate so Dynamic‑LINQ has a numeric overload; when wrapping user‑supplied aggregates always ensure numeric ones read Sum(Convert.ToDecimal(Accessor(col))) or similar.  Apply query = query.GroupBy(keyExpr).Select('new(' + keySelect + aggregateParts + ')') when both groupBy and aggregate exist; if only groupBy exists just select keySelect; if only aggregate exists select the aggregateParts directly. **Select stage**: rebuild the projection so each item is kept verbatim when it already contains ' as ', otherwise becomes Accessor(s) + ' as ' + s.Split('.').Last(). **Sort**: replace full dotted column names inside the sort string with their Alias equivalents, then run query.OrderBy(sort) if sort present. **Limit**: query.Take(limit) when limit>0. Materialise with query.ToDynamicList() and return.  Example that must work without any runtime errors: compute {\"StartYear\":\"start_date != null && start_date.Length >= 4 ? start_date.Substring(0,4) : \\\"Unknown\\\"\"}, groupBy [\"StartYear\"], aggregate {\"Projects\":\"Count()\"}, select [\"StartYear\",\"Projects\"], sort \"StartYear\", limit 10 – this groups projects by their four‑digit start year, counts them, and returns the first ten years in ascending order even when some rows have empty start_date values. When you build any Dynamic‑LINQ expression **always cast row values to the type you are about to use**; never call a member directly on the raw object that comes out of the dictionary.  A safe pattern for string work is  str = Convert.ToString(<column>)  and for numeric work  num = Convert.ToDecimal(<column>).  Example: to derive a four‑digit year use  (Convert.ToString(start_date)?.Length ?? 0) >= 4 ? Convert.ToString(start_date).Substring(0,4) : \"Onbekend\".  With that rule the binary operator errors disappear because the operands are now both concrete types (string, decimal, int) and Dynamic‑LINQ can pick the correct overload.  Update every compute expression you generate or accept so it follows this rule, and document it for users: **always wrap a column reference in Convert.ToString, Convert.ToInt32, Convert.ToDecimal, etc., before using properties, methods, arithmetic or comparisons**.  The rest of the pipeline stays identical: compute first, then filter, group/aggregate, select, sort (OrderBy must refer to aliases not dotted names), limit, finally ToDynamicList(). Dynamic‑LINQ only recognises the exact C# LINQ aggregate method names **Average, Sum, Min, Max, Count**.  Shorthands such as **Avg** do not exist and cause the runtime error ‘No generic method … is compatible’.  Therefore, before you send an aggregate expression to Dynamic‑LINQ, always run this textual normalisation:  (1) Replace every whole‑word token ‘Avg(’ or ‘avg(’ with ‘Average(’.  (A simple Regex like  \\bAvg\\s*\\(  →  Average(  is enough; keep the original spacing after the token.)  After this substitution the expression is syntactically valid.  (2) Make sure every numeric operand inside the aggregate is explicitly cast, e.g.  Convert.ToDecimal(…); this guarantees Dynamic‑LINQ chooses the generic overload of Average/ Sum/ etc.  (3) If an expression performs division and the denominator may be zero, wrap it with a conditional and return **null** for the zero case so Average ignores that row:  Average( (Convert.ToDecimal(budget.total.value_budget)==0 ? null : Convert.ToDecimal(budget.total.value_invoiced)/Convert.ToDecimal(budget.total.value_budget)) ).  (4) After normalisation build the query pipeline exactly as before: compute → filter → group/aggregate → select → sort → limit → materialise with ToDynamicList().  Example that MUST compile and run:  groupBy:[\"project_status.label\"], aggregate:{\"MeanInvoicingRatio\":\"Average((Convert.ToDecimal(budget.total.value_budget)==0 ? null : Convert.ToDecimal(budget.total.value_invoiced)/Convert.ToDecimal(budget.total.value_budget)))\"}, select:[\"project_status.label\",\"MeanInvoicingRatio\"].  This yields the average invoicing ratio per project status with no ‘no generic method Average’ or ‘no applicable indexer’ errors.",
  "plugins": [
    "MCPhappey.Tools.DataAnalysis.DataAnalysisPlugin, MCPhappey.Tools"
  ],
  "obo": {
    "graph.microsoft.com": "https://graph.microsoft.com/User.Read https://graph.microsoft.com/Files.ReadWrite"
  }
}